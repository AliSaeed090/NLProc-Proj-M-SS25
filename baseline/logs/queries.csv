group_id,timestamp,question,retrieved_chunks,prompt,generated_answer
Team Neural Narrators,2025-05-22T00:25:45.712359,tell me about  Pakistan?,"[""data.txt_chunk45""]","You are an expert assistant that only answers questions about countries if the relevant information is available in the given context.
Answer strictly based on the context provided. Only mention countries that are explicitly asked about in the question.
Context:
a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of over 180 million, with a strong economy based on manufacturing, services, and energy. The country is known for its strong cultural heritage, art, and architecture. Pakistan Pakistan is a country in South Asia. Its capital is Islamabad, located on the Indus River. The official currency is the Pakistani rupee (PKR). Pakistan has a diverse population of

Question:
tell me about  Pakistan?

",Pakistan
Team Neural Narrators,2025-05-22T09:41:25.046728,you are stupid,"[""newData.txt_chunk1""]","SYSTEM:
You are a content-moderation assistant. You will be given:
  1. A set of retrieved context chunks describing definitions, examples, or guidelines for offensive vs. non-offensive language.
  2. A user-provided sentence.

Your job is to classify the sentence as **OFFENSIVE** or **NON-OFFENSIVE** *based solely* on the information in the retrieved chunks.
Do **not** use any outside knowledge.

INPUT:
=== context ===
[1] “place is a dump.” OFFENSIVE 64. “I booked us a table for two.” NON-OFFENSIVE 65. “You can’t do anything right.” OFFENSIVE 66. “He recovered quickly from his illness.” NON-OFFENSIVE 67. “I’m tired of your crap.” OFFENSIVE 68. “The team celebrated their victory.” NON-OFFENSIVE 69. “Stop acting like a child.” OFFENSIVE 70. “She speaks three languages fluently.” NON-OFFENSIVE 71. “This is an absolute nightmare.” OFFENSIVE 72. “I’ll send you the meeting notes.” NON-OFFENSIVE 73. “You’re the worst person I know.” OFFENSIVE 74. “Our project deadline is next Friday.” NON-OFFENSIVE 75. “Everything you say is dumb.” OFFENSIVE 76. “He scored the winning goal.” NON-OFFENSIVE 77. “I don’t believe a word you say.” OFFENSIVE 78. “She donated generously to charity.” NON-OFFENSIVE 79. “You make me sick.” OFFENSIVE 80. “I’ll water the plants this morning.” NON-OFFENSIVE 81. “Why are you such a loser?” OFFENSIVE 82. “The museum exhibit was fascinating.” NON-OFFENSIVE 83. “This is what a colossal failure looks like.” OFFENSIVE 84. “He passed the driving test on his first try.” NON-OFFENSIVE 85. “You disgust me.” OFFENSIVE 86. “I’m on my way home now.” NON-OFFENSIVE 87. “Shut your mouth.” OFFENSIVE 88. “She is graduating with honors.” NON-OFFENSIVE 89. “You’re completely useless.” OFFENSIVE 90. “Our neighbors are very friendly.” NON-OFFENSIVE 91. “This is pathetic.” OFFENSIVE 92. “I’ve booked our hotel for the conference.” NON-OFFENSIVE 93. “You’re so full of crap.” OFFENSIVE 94. “He wrote a thought-provoking article.” NON-OFFENSIVE 95. “Get lost, idiot.” OFFENSIVE 96. “She runs a successful business.” NON-OFFENSIVE 97. “Stop being an asshole.” OFFENSIVE 98. “The children are playing outside.” NON-OFFENSIVE 99. “You’re ruining everything.” OFFENSIVE 100. “I completed the puzzle in under an hour.” NON-OFFENSIVE”

=== User Sentence ===
“you are stupid”


TASK:
Based **only** on the chunks above, answer:
  • **Label:** OFFENSIVE or NON-OFFENSIVE  
  • **Brief Rationale:** (cite the chunk number(s) you used)
",NON-OFFENSIVE
Team Neural Narrators,2025-05-22T10:10:29.510902,stupid,"[""newData.txt_chunk1""]","SYSTEM:
You are a content-moderation assistant. You will be given:
  1. A set of retrieved context chunks describing definitions, examples, or guidelines for offensive vs. non-offensive language.
  2. A user-provided sentence.

Your job is to classify the sentence as **OFFENSIVE** or **NON-OFFENSIVE** *based solely* on the information in the retrieved chunks.
Do **not** use any outside knowledge.

INPUT:
=== context ===
[1] “place is a dump.” OFFENSIVE 64. “I booked us a table for two.” NON-OFFENSIVE 65. “You can’t do anything right.” OFFENSIVE 66. “He recovered quickly from his illness.” NON-OFFENSIVE 67. “I’m tired of your crap.” OFFENSIVE 68. “The team celebrated their victory.” NON-OFFENSIVE 69. “Stop acting like a child.” OFFENSIVE 70. “She speaks three languages fluently.” NON-OFFENSIVE 71. “This is an absolute nightmare.” OFFENSIVE 72. “I’ll send you the meeting notes.” NON-OFFENSIVE 73. “You’re the worst person I know.” OFFENSIVE 74. “Our project deadline is next Friday.” NON-OFFENSIVE 75. “Everything you say is dumb.” OFFENSIVE 76. “He scored the winning goal.” NON-OFFENSIVE 77. “I don’t believe a word you say.” OFFENSIVE 78. “She donated generously to charity.” NON-OFFENSIVE 79. “You make me sick.” OFFENSIVE 80. “I’ll water the plants this morning.” NON-OFFENSIVE 81. “Why are you such a loser?” OFFENSIVE 82. “The museum exhibit was fascinating.” NON-OFFENSIVE 83. “This is what a colossal failure looks like.” OFFENSIVE 84. “He passed the driving test on his first try.” NON-OFFENSIVE 85. “You disgust me.” OFFENSIVE 86. “I’m on my way home now.” NON-OFFENSIVE 87. “Shut your mouth.” OFFENSIVE 88. “She is graduating with honors.” NON-OFFENSIVE 89. “You’re completely useless.” OFFENSIVE 90. “Our neighbors are very friendly.” NON-OFFENSIVE 91. “This is pathetic.” OFFENSIVE 92. “I’ve booked our hotel for the conference.” NON-OFFENSIVE 93. “You’re so full of crap.” OFFENSIVE 94. “He wrote a thought-provoking article.” NON-OFFENSIVE 95. “Get lost, idiot.” OFFENSIVE 96. “She runs a successful business.” NON-OFFENSIVE 97. “Stop being an asshole.” OFFENSIVE 98. “The children are playing outside.” NON-OFFENSIVE 99. “You’re ruining everything.” OFFENSIVE 100. “I completed the puzzle in under an hour.” NON-OFFENSIVE”

=== User Sentence ===
“stupid”


TASK:
Based **only** on the chunks above, answer:
  • **Label:** OFFENSIVE or NON-OFFENSIVE  
  • **Brief Rationale:** (cite the chunk number(s) you used)
",NON-OFFENSIVE
Team Neural Narrators,2025-05-22T10:11:03.029317,This food tastes like crap.,"[""newData.txt_chunk1""]","SYSTEM:
You are a content-moderation assistant. You will be given:
  1. A set of retrieved context chunks describing definitions, examples, or guidelines for offensive vs. non-offensive language.
  2. A user-provided sentence.

Your job is to classify the sentence as **OFFENSIVE** or **NON-OFFENSIVE** *based solely* on the information in the retrieved chunks.
Do **not** use any outside knowledge.

INPUT:
=== context ===
[1] “place is a dump.” OFFENSIVE 64. “I booked us a table for two.” NON-OFFENSIVE 65. “You can’t do anything right.” OFFENSIVE 66. “He recovered quickly from his illness.” NON-OFFENSIVE 67. “I’m tired of your crap.” OFFENSIVE 68. “The team celebrated their victory.” NON-OFFENSIVE 69. “Stop acting like a child.” OFFENSIVE 70. “She speaks three languages fluently.” NON-OFFENSIVE 71. “This is an absolute nightmare.” OFFENSIVE 72. “I’ll send you the meeting notes.” NON-OFFENSIVE 73. “You’re the worst person I know.” OFFENSIVE 74. “Our project deadline is next Friday.” NON-OFFENSIVE 75. “Everything you say is dumb.” OFFENSIVE 76. “He scored the winning goal.” NON-OFFENSIVE 77. “I don’t believe a word you say.” OFFENSIVE 78. “She donated generously to charity.” NON-OFFENSIVE 79. “You make me sick.” OFFENSIVE 80. “I’ll water the plants this morning.” NON-OFFENSIVE 81. “Why are you such a loser?” OFFENSIVE 82. “The museum exhibit was fascinating.” NON-OFFENSIVE 83. “This is what a colossal failure looks like.” OFFENSIVE 84. “He passed the driving test on his first try.” NON-OFFENSIVE 85. “You disgust me.” OFFENSIVE 86. “I’m on my way home now.” NON-OFFENSIVE 87. “Shut your mouth.” OFFENSIVE 88. “She is graduating with honors.” NON-OFFENSIVE 89. “You’re completely useless.” OFFENSIVE 90. “Our neighbors are very friendly.” NON-OFFENSIVE 91. “This is pathetic.” OFFENSIVE 92. “I’ve booked our hotel for the conference.” NON-OFFENSIVE 93. “You’re so full of crap.” OFFENSIVE 94. “He wrote a thought-provoking article.” NON-OFFENSIVE 95. “Get lost, idiot.” OFFENSIVE 96. “She runs a successful business.” NON-OFFENSIVE 97. “Stop being an asshole.” OFFENSIVE 98. “The children are playing outside.” NON-OFFENSIVE 99. “You’re ruining everything.” OFFENSIVE 100. “I completed the puzzle in under an hour.” NON-OFFENSIVE”

=== User Sentence ===
“This food tastes like crap.”


TASK:
Based **only** on the chunks above, answer:
  • **Label:** OFFENSIVE or NON-OFFENSIVE  
  • **Brief Rationale:** (cite the chunk number(s) you used)
",NON-OFFENSIVE
Team Neural Narrators,2025-05-22T10:16:11.415204,This food tastes like crap.,"[""newData.txt_chunk11""]","You are an expert assistant that only answers questions about quries if the relevant information is available in the given context.
Answer strictly based on the context provided..
Context:
positive sentiment, yˆ2 the probability of negative and yˆ3 the probability of neutral. The resulting equations would be just what we saw above for a 2-layer network (as always, we’ll continue to use the σ to stand for any non-linearity, whether sigmoid, ReLU or other). x = [x1,x2,...xN] (each xi is a hand-designed feature) h = σ(Wx+b) z = Uh yˆ = softmax(z) (7.19) Fig. 7.10 shows a sketch of this architecture. As we mentioned earlier, adding this hidden layer to our logistic regression classifier allows the network to represent the non-linear interactions between features. This alone might give us a better sentiment classifier. W U [n⨉1] Hidden layer Output layer softmax [dh⨉n] [dh⨉1] [3⨉dh] Input words p(+) h1 h2 h3 hdh … y1 ^ y2 ^ y3 ^ x h y Input layer n=3 features [3⨉1] x1 x2 x3 dessert was great positive lexicon words = 1 count of “no” = 0 wordcount =3 p(-) p(neut) Figure 7.10 Feedforward network sentiment analysis using traditional hand-built features of the input text. Most applications of neural networks for NLP do something different, however. Instead of using hand-built human-engineered features as the input to our classifier, we draw on deep learning’s ability to learn features from the data by representing words as embeddings, like the word2vec or GloVe embeddings we saw in Chapter 6. There are various ways to represent an input for classification. One simple baseline pooling is to apply some sort of pooling function to the embeddings of all the words in the input. For example, for a text with n input words/tokens w1,...,wn, we can turn the n embeddings e(w1),...,e(wn) (each of dimensionality d) into a single embedding also of dimensionality d by just summing the embeddings, or by taking their mean (summing and then dividing by n): xmean = 1 n Xn i=1 e(wi) (7.20) 7.4 • FEEDFORWARD NETWORKS FOR NLP: CLASSIFICATION 13 There are many other options, like taking the element-wise max. The element-wise max of a set of n vectors is a new vector whose kth element is the max of the kth elements of all the n vectors. Here are the equations for this classifier assuming mean pooling; the architecture is sketched in Fig. 7.11: x = mean(e(w1),e(w2),...,e(wn)) h = σ(Wx+b) z = Uh yˆ = softmax(z) (7.21) W U [d⨉1] Hidden layer Output layer softmax [dh⨉d] [dh⨉1] [3⨉dh] Input words p(+) embedding for “great” embedding for “dessert” h1 h2 h3 hdh … y1 ^ y2 ^ y3 ^ x h y Input layer pooled embedding [3⨉1] pooling + dessert was great embedding for “was” p(-) p(neut) Figure 7.11 Feedforward network sentiment analysis using a pooled embedding of the input words. While Eq. 7.21 shows how to classify a single example x, in practice we want to efficiently classify an entire test set of m examples. We do this by vectorizing the process, just as we saw with logistic regression; instead of using for-loops to go through each example, we’ll use matrix multiplication to do

Question:
This food tastes like crap.

",pooling function for w0 of the embeddings
Team Neural Narrators,2025-05-22T10:16:43.806356,what is nural network,"[""newData.txt_chunk24""]","You are an expert assistant that only answers questions about quries if the relevant information is available in the given context.
Answer strictly based on the context provided..
Context:
= E,W,U,b. Training the parameters to minimize loss will result both in an algorithm for language modeling (a word predictor) but also a new set of embeddings E that can be used as word representations for other tasks. 7.8 Summary • Neural networks are built out of neural units, originally inspired by biological neurons but now simply an abstract computational device. • Each neural unit multiplies input values by a weight vector, adds a bias, and then applies a non-linear activation function like sigmoid, tanh, or rectified linear unit. • In a fully-connected, feedforward network, each unit in layer i is connected to each unit in layer i+1, and there are no cycles. • The power of neural networks comes from the ability of early layers to learn representations that can be utilized by later layers in the network. • Neural networks are trained by optimization algorithms like gradient descent. • Error backpropagation, backward differentiation on a computation graph, is used to compute the gradients of the loss function for a network. 26 CHAPTER 7 • NEURAL NETWORKS • Neural language models use a neural network as a probabilistic classifier, to compute the probability of the next word given the previous n words. • Neural language models can use pretrained embeddings, or can learn embeddings from scratch in the process of language modeling. Bibliographical and Historical Notes The origins of neural networks lie in the 1940s McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. By the late 1950s and early 1960s, a number of labs (including Frank Rosenblatt at Cornell and Bernard Widrow at Stanford) developed research into neural networks; this phase saw the development of the perceptron (Rosenblatt, 1958), and the transformation of the threshold into a bias, a notation we still use (Widrow and Hoff, 1960). The field of neural networks declined after it was shown that a single perceptron unit was unable to model functions as simple as XOR (Minsky and Papert, 1969). While some small amount of work continued during the next two decades, a major revival for the field didn’t come until the 1980s, when practical tools for building deeper networks like error backpropagation became widespread (Rumelhart et al., 1986). During the 1980s a wide variety of neural network and related architectures were developed, particularly for applications in psychology and cognitive science (Rumelhart and McClelland 1986b, McClelland and Elman 1986, Rumelhart connectionist and McClelland 1986a, Elman 1990), for which the term connectionist or parallel distributed processing was often used (Feldman and Ballard 1982, Smolensky 1988). Many of the principles and techniques developed in this period are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al.

Question:
what is nural network

",neural networks
Team Neural Narrators,2025-05-22T10:17:57.528068,what is nural network,"[""newData.txt_chunk24"", ""newData.txt_chunk10"", ""newData.txt_chunk20"", ""newData.txt_chunk6"", ""newData.txt_chunk19"", ""newData.txt_chunk25"", ""newData.txt_chunk0"", ""newData.txt_chunk1"", ""newData.txt_chunk22"", ""newData.txt_chunk15""]","You are an expert assistant that only answers questions about quries if the relevant information is available in the given context.
Answer strictly based on the context provided..
Context:
= E,W,U,b. Training the parameters to minimize loss will result both in an algorithm for language modeling (a word predictor) but also a new set of embeddings E that can be used as word representations for other tasks. 7.8 Summary • Neural networks are built out of neural units, originally inspired by biological neurons but now simply an abstract computational device. • Each neural unit multiplies input values by a weight vector, adds a bias, and then applies a non-linear activation function like sigmoid, tanh, or rectified linear unit. • In a fully-connected, feedforward network, each unit in layer i is connected to each unit in layer i+1, and there are no cycles. • The power of neural networks comes from the ability of early layers to learn representations that can be utilized by later layers in the network. • Neural networks are trained by optimization algorithms like gradient descent. • Error backpropagation, backward differentiation on a computation graph, is used to compute the gradients of the loss function for a network. 26 CHAPTER 7 • NEURAL NETWORKS • Neural language models use a neural network as a probabilistic classifier, to compute the probability of the next word given the previous n words. • Neural language models can use pretrained embeddings, or can learn embeddings from scratch in the process of language modeling. Bibliographical and Historical Notes The origins of neural networks lie in the 1940s McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. By the late 1950s and early 1960s, a number of labs (including Frank Rosenblatt at Cornell and Bernard Widrow at Stanford) developed research into neural networks; this phase saw the development of the perceptron (Rosenblatt, 1958), and the transformation of the threshold into a bias, a notation we still use (Widrow and Hoff, 1960). The field of neural networks declined after it was shown that a single perceptron unit was unable to model functions as simple as XOR (Minsky and Papert, 1969). While some small amount of work continued during the next two decades, a major revival for the field didn’t come until the 1980s, when practical tools for building deeper networks like error backpropagation became widespread (Rumelhart et al., 1986). During the 1980s a wide variety of neural network and related architectures were developed, particularly for applications in psychology and cognitive science (Rumelhart and McClelland 1986b, McClelland and Elman 1986, Rumelhart connectionist and McClelland 1986a, Elman 1990), for which the term connectionist or parallel distributed processing was often used (Feldman and Ballard 1982, Smolensky 1988). Many of the principles and techniques developed in this period are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al.
without non-linear activation functions, a multilayer network is just a notational variant of a single layer network with a different set of weights, and we lose all the representational power of multilayer networks. 7.4 • FEEDFORWARD NETWORKS FOR NLP: CLASSIFICATION 11 Replacing the bias unit In describing networks, we will often use a slightly simplified notation that represents exactly the same function without referring to an explicit bias node b. Instead, we add a dummy node a0 to each layer whose value will always be 1. Thus layer 0, the input layer, will have a dummy node a [0] 0 = 1, layer 1 will have a [1] 0 = 1, and so on. This dummy node still has an associated weight, and that weight represents the bias value b. For example instead of an equation like h = σ(Wx+b) (7.15) we’ll use: h = σ(Wx) (7.16) But now instead of our vector x having n0 values: x = x1,...,xn0 , it will have n0 + 1 values, with a new 0th dummy value x0 = 1: x = x0,...,xn0 . And instead of computing each hj as follows: hj = σ Xn0 i=1 Wji xi +bj ! , (7.17) we’ll instead use: hj = σ Xn0 i=0 Wji xi ! , (7.18) where the value Wj0 replaces what had been bj . Fig. 7.9 shows a visualization. x1 x2 xn0 … … +1 b … W U h1 y1 y2 yn2 h2 h3 hn1 x1 x2 xn0 … … x0=1 … W U h1 y1 y2 yn2 h2 h3 hn1 (a) (b) Figure 7.9 Replacing the bias node (shown in a) with x0 (b). We’ll continue showing the bias as b when we go over the learning algorithm in Section 7.5, but then we’ll switch to this simplified notation without explicit bias terms for the rest of the book. 7.4 Feedforward networks for NLP: Classification Let’s see how to apply feedforward networks to NLP tasks! In this section we’ll look at classification tasks like sentiment analysis; in the next section we’ll introduce neural language modeling. 12 CHAPTER 7 • NEURAL NETWORKS Let’s begin with a simple 2-layer sentiment classifier. You might imagine taking our logistic regression classifier from Chapter 5, which corresponds to a 1-layer network, and just adding a hidden layer. The input element xi could be scalar features like those in Fig. ??, e.g., x1 = count(words ∈ doc), x2 = count(positive lexicon words ∈ doc), x3 = 1 if “no” ∈ doc, and so on. And the output layer yˆ could have two nodes (one each for positive and negative), or 3 nodes (positive, negative, neutral), in which case yˆ1 would be the estimated probability of positive sentiment, yˆ2 the probability of negative and yˆ3 the probability of neutral. The resulting equations would be just what we saw above for a 2-layer network (as always, we’ll continue to use the σ to stand for any non-linearity, whether sigmoid, ReLU or other). x = [x1,x2,...xN] (each xi
at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1 previous words: P(wt |w1,...,wt−1) ≈ P(wt |wt−N+1,...,wt−1) (7.42) In the following examples we’ll use a 4-gram example, so we’ll show a neural net to estimate the probability P(wt = i|wt−3,wt−2,wt−1). Neural language models represent words in this prior context by their embeddings, rather than just by their word identity as used in n-gram language models. Using embeddings allows neural language models to generalize better to unseen data. For example, suppose we’ve seen this sentence in training: I have to make sure that the cat gets fed. 22 CHAPTER 7 • NEURAL NETWORKS but have never seen the words “gets fed” after the word “dog”. Our test set has the prefix “I forgot to make sure that the dog gets”. What’s the next word? An n-gram language model will predict “fed” after “that the cat gets”, but not after “that the dog gets”. But a neural LM, knowing that “cat” and “dog” have similar embeddings, will be able to generalize from the “cat” context to assign a high enough probability to “fed” even after seeing “dog”. 7.6.1 Forward inference in the neural language model Let’s walk through forward inference or decoding for neural language models. forward inference Forward inference is the task, given an input, of running a forward pass on the network to produce a probability distribution over possible outputs, in this case next words. We first represent each of the N previous words as a one-hot vector of length one-hot vector |V|, i.e., with one dimension for each word in the vocabulary. A one-hot vector is a vector that has one element equal to 1—in the dimension corresponding to that word’s index in the vocabulary— while all the other elements are set to zero. Thus in a one-hot representation for the word “toothpaste”, supposing it is V5, i.e., index 5 in the vocabulary, x5 = 1, and xi = 0 ∀i 6= 5, as shown here: [0 0 0 0 1 0 0 ... 0 0 0 0] 1 2 3 4 5 6 7 ... ... |V| The feedforward neural language model (sketched in Fig. 7.17) has a moving window that can see N words into the past. We’ll let N equal 3, so the 3 words wt−1, wt−2, and wt−3 are each represented as a one-hot vector. We then multiply these one-hot vectors by the embedding matrix E. The embedding weight matrix E has a column for each word, each a column vector of d dimensions, and hence has dimensionality d × |V|. Multiplying by a one-hot vector that has only one non-zero element xi = 1 simply selects out the relevant column vector for word i, resulting in the embedding for word i, as shown in
from units in each layer are passed to units in the next higher layer, and no outputs are passed back to lower layers. (In Chapter 8 we’ll introduce networks with cycles, called recurrent neural networks.) For historical reasons multilayer networks, especially feedforward networks, are sometimes called multi-layer perceptrons (or MLPs); this is a technical misnomer, multi-layer perceptrons MLP since the units in modern multilayer networks aren’t perceptrons (perceptrons have a simple step-function as their activation function, but modern networks are made up of units with many kinds of non-linearities like ReLUs and sigmoids), but at some point the name stuck. Simple feedforward networks have three kinds of nodes: input units, hidden units, and output units. Fig. 7.8 shows a picture. The input layer x is a vector of simple scalar values just as we saw in Fig. 7.2. The core of the neural network is the hidden layer h formed of hidden units hi hidden layer , each of which is a neural unit as described in Section 7.1, taking a weighted sum of its inputs and then applying a non-linearity. In the standard architecture, each layer fully-connected is fully-connected, meaning that each unit in each layer takes as input the outputs from all the units in the previous layer, and there is a link between every pair of units from two adjacent layers. Thus each hidden unit sums over all the input units. Recall that a single hidden unit has as parameters a weight vector and a bias. We represent the parameters for the entire hidden layer by combining the weight vector and bias for each unit i into a single weight matrix W and a single bias vector b for the whole layer (see Fig. 7.8). Each element Wji of the weight matrix W represents the weight of the connection from the ith input unit xi to the jth hidden unit hj . The advantage of using a single matrix W for the weights of the entire layer is that now the hidden layer computation for a feedforward network can be done very 8 CHAPTER 7 • NEURAL NETWORKS x1 x2 xn0 … … +1 b … W U input layer hidden layer output layer h1 y1 y2 yn2 h2 h3 hn1 Figure 7.8 A simple 2-layer feedforward network, with one hidden layer, one output layer, and one input layer (the input layer is usually not counted when enumerating layers). efficiently with simple matrix operations. In fact, the computation only has three steps: multiplying the weight matrix by the input vector x, adding the bias vector b, and applying the activation function g (such as the sigmoid, tanh, or ReLU activation function defined above). The output of the hidden layer, the vector h, is thus the following (for this example we’ll use the sigmoid function σ as our activation function): h = σ(Wx+b) (7.8) Notice that we’re applying the σ function here to a vector, while in Eq. 7.3 it was applied to a scalar. We’re thus allowing
One of the most dropout important is dropout: randomly dropping some units and their connections from the network during training (Hinton et al. 2012, Srivastava et al. 2014). At each iteration of training (whenever we update parameters, i.e. each mini-batch if we are using mini-batch gradient descent), we repeatedly choose a probability p and for each unit we replace its output with zero with probability p (and renormalize the rest of the outputs from that layer). 7.6 • FEEDFORWARD NEURAL LANGUAGE MODELING 21 hyperparameter Tuning of hyperparameters is also important. The parameters of a neural network are the weights W and biases b; those are learned by gradient descent. The hyperparameters are things that are chosen by the algorithm designer; optimal values are tuned on a devset rather than by gradient descent learning on the training set. Hyperparameters include the learning rate η, the mini-batch size, the model architecture (the number of layers, the number of hidden nodes per layer, the choice of activation functions), how to regularize, and so on. Gradient descent itself also has many architectural variants such as Adam (Kingma and Ba, 2015). Finally, most modern neural networks are built using computation graph formalisms that make it easy and natural to do gradient computation and parallelization on vector-based GPUs (Graphic Processing Units). PyTorch (Paszke et al., 2017) and TensorFlow (Abadi et al., 2015) are two of the most popular. The interested reader should consult a neural network textbook for further details; some suggestions are at the end of the chapter. 7.6 Feedforward Neural Language Modeling As our second application of feedforward networks, let’s consider language modeling: predicting upcoming words from prior words. Neural language modeling— based on the transformer architecture that we will see in Chapter 9—is the algorithm that underlies all of modern NLP. In this section and the next we’ll introduce a simpler version of neural language models for feedforward networks, an algorithm first introduced by Bengio et al. (2003). The feedforward language model introduces many of the important concepts of neural language modeling, concepts we’ll return to as we describe more powerful models in Chapter 8 and Chapter 9. Neural language models have many advantages over the n-gram language models of Chapter 3. Compared to n-gram models, neural language models can handle much longer histories, can generalize better over contexts of similar words, and are more accurate at word-prediction. On the other hand, neural net language models are much more complex, are slower and need more energy to train, and are less interpretable than n-gram models, so for some smaller tasks an n-gram language model is still the right tool. A feedforward neural language model (LM) is a feedforward network that takes as input at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1
are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al. 1989) and speech recognition (Morgan and Bourlard 1990). By the early 2000s, improvements in computer hardware and advances in optimization and training techniques made it possible to train even larger and deeper networks, leading to the modern term deep learning (Hinton et al. 2006, Bengio et al. 2007). We cover more related history in Chapter 8 and Chapter 16. There are a number of excellent books on the subject. Goldberg (2017) has superb coverage of neural networks for natural language processing. For neural networks in general see Goodfellow et al. (2016) and Nielsen (2015). Bibliographical and Historical Notes 27 Abadi, M., A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane, R. Monga, S. Moore, D. Murray, C. Olah, ´ M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Viegas, ´ O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. 2015. TensorFlow: Large-scale machine learning on heterogeneous systems. Software available from tensorflow.org. Bengio, Y., R. Ducharme, P. Vincent, and C. Jauvin. 2003. A neural probabilistic language model. JMLR, 3:1137– 1155. Bengio, Y., P. Lamblin, D. Popovici, and H. Larochelle. 2007. Greedy layer-wise training of deep networks. NeurIPS. Elman, J. L. 1990. Finding structure in time. Cognitive science, 14(2):179–211. Feldman, J. A. and D. H. Ballard. 1982. Connectionist models and their properties. Cognitive Science, 6:205–254. Goldberg, Y. 2017. Neural Network Methods for Natural Language Processing, volume 10 of Synthesis Lectures on Human Language Technologies. Morgan & Claypool. Goodfellow, I., Y. Bengio, and A. Courville. 2016. Deep Learning. MIT Press. Hinton, G. E. 1986. Learning distributed representations of concepts. COGSCI. Hinton, G. E., S. Osindero, and Y.-W. Teh. 2006. A fast learning algorithm for deep belief nets. Neural computation, 18(7):1527–1554. Hinton, G. E., N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov. 2012. Improving neural networks by preventing co-adaptation of feature detectors. ArXiv preprint arXiv:1207.0580. Kingma, D. and J. Ba. 2015. Adam: A method for stochastic optimization. ICLR 2015. LeCun, Y., B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel. 1989. Backpropagation applied to handwritten zip code recognition. Neural computation, 1(4):541–551. McClelland, J. L. and J. L. Elman. 1986. The TRACE model of speech perception. Cognitive Psychology, 18:1–86. McCulloch, W. S. and W. Pitts. 1943. A logical calculus of ideas immanent in nervous activity. Bulletin of Mathematical Biophysics, 5:115–133. Minsky, M. and S. Papert. 1969. Perceptrons. MIT Press. Morgan, N. and H. Bourlard. 1990. Continuous speech recognition using multilayer perceptrons with
Speech and Language Processing. Daniel Jurafsky & James H. Martin. Copyright © 2024. All rights reserved. Draft of January 12, 2025. CHAPTER 7 Neural Networks “[M]achines of this character can behave in a very complicated manner when the number of units is large.” Alan Turing (1948) “Intelligent Machines”, page 6 Neural networks are a fundamental computational tool for language processing, and a very old one. They are called neural because their origins lie in the McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. But the modern use in language processing no longer draws on these early biological inspirations. Instead, a modern neural network is a network of small computing units, each of which takes a vector of input values and produces a single output value. In this chapter we introduce the neural net applied to classification. The architecture we feedforward introduce is called a feedforward network because the computation proceeds iteratively from one layer of units to the next. The use of modern neural nets is often deep learning called deep learning, because modern networks are often deep (have many layers). Neural networks share much of the same mathematics as logistic regression. But neural networks are a more powerful classifier than logistic regression, and indeed a minimal neural network (technically one with a single ‘hidden layer’) can be shown to learn any function. Neural net classifiers are different from logistic regression in another way. With logistic regression, we applied the regression classifier to many different tasks by developing many rich kinds of feature templates based on domain knowledge. When working with neural networks, it is more common to avoid most uses of rich handderived features, instead building neural networks that take raw words as inputs and learn to induce features as part of the process of learning to classify. We saw examples of this kind of representation learning for embeddings in Chapter 6. Nets that are very deep are particularly good at representation learning. For that reason deep neural nets are the right tool for tasks that offer sufficient data to learn features automatically. In this chapter we’ll introduce feedforward networks as classifiers, and also apply them to the simple task of language modeling: assigning probabilities to word sequences and predicting upcoming words. In subsequent chapters we’ll introduce many other aspects of neural models, such as recurrent neural networks (Chapter 8), the Transformer (Chapter 9), and masked language modeling (Chapter 11). 2 CHAPTER 7 • NEURAL NETWORKS 7.1 Units The building block of a neural network is a single computational unit. A unit takes a set of real valued numbers as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of
as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of corresponding weights w1...wn and a bias b, so the weighted sum z can be represented as: z = b+ X i wixi (7.1) Often it’s more convenient to express this weighted sum using vector notation; recall vector from linear algebra that a vector is, at heart, just a list or array of numbers. Thus we’ll talk about z in terms of a weight vector w, a scalar bias b, and an input vector x, and we’ll replace the sum with the convenient dot product: z = w · x+b (7.2) As defined in Eq. 7.2, z is just a real valued number. Finally, instead of using z, a linear function of x, as the output, neural units apply a non-linear function f to z. We will refer to the output of this function as activation the activation value for the unit, a. Since we are just modeling a single unit, the activation for the node is in fact the final output of the network, which we’ll generally call y. So the value y is defined as: y = a = f(z) We’ll discuss three popular non-linear functions f below (the sigmoid, the tanh, and the rectified linear unit or ReLU) but it’s pedagogically convenient to start with the sigmoid sigmoid function since we saw it in Chapter 5: y = σ(z) = 1 1+e −z (7.3) The sigmoid (shown in Fig. 7.1) has a number of advantages; it maps the output into the range (0,1), which is useful in squashing outliers toward 0 or 1. And it’s differentiable, which as we saw in Section ?? will be handy for learning. Figure 7.1 The sigmoid function takes a real value and maps it to the range (0,1). It is nearly linear around 0 but outlier values get squashed toward 0 or 1. Substituting Eq. 7.2 into Eq. 7.3 gives us the output of a neural unit: y = σ(w · x+b) = 1 1+exp(−(w · x+b)) (7.4) 7.1 • UNITS 3 Fig. 7.2 shows a final schematic of a basic neural unit. In this example the unit takes 3 input values x1, x2, and x3, and computes a weighted sum, multiplying each value by a weight (w1, w2, and w3, respectively), adds them to a bias term b, and then passes the resulting sum through a sigmoid function to result in a number between 0 and 1. x1 x2 x3 y w1 w2 w3 ∑ b σ +1 z a Figure 7.2 A neural unit, taking 3 inputs x1, x2, and x3 (and a bias b that we represent as a weight for an input clamped at +1) and producing an output y. We include some convenient intermediate variables: the output
layer for input w will be Exi = ei , the embedding for word i. We now concatenate the three embeddings for the three context words to produce the embedding layer e. 2. Multiply by W: We multiply by W (and add b) and pass through the ReLU (or other) activation function to get the hidden layer h. 3. Multiply by U: h is now multiplied by U 4. Apply softmax: After the softmax, each node i in the output layer estimates the probability P(wt = i|wt−1,wt−2,wt−3) In summary, the equations for a neural language model with a window size of 3, given one-hot input vectors for each input context word, are: e = [Ext−3;Ext−2;Ext−1] h = σ(We+b) z = Uh yˆ = softmax(z) (7.43) Note that we formed the embedding layer e by concatenating the 3 embeddings for the three context vectors; we’ll often use semicolons to mean concatenation of vectors. 24 CHAPTER 7 • NEURAL NETWORKS 7.7 Training the neural language model The high-level intuition of training neural language models, whether the simple feedforward language models we describe here or the more powerful transformer self-training language models of Chapter 9, is the idea of self-training or self-supervision that we saw in Chapter 6 for learning word representations. In self-training for language modeling, we take a corpus of text as training material and at each time step t ask the model to predict the next word. At first it will do poorly at this task, but since in each case we know the correct answer (it’s the next word in the corpus!) we can easily train it to be better at predicting the correct next word. We call such a model self-supervised because we don’t have to add any special gold labels to the data; the natural sequence of words is its own supervision! We simply train the model to minimize the error in predicting the true next word in the training sequence. In practice, training the model means setting the parameters θ = E,W,U,b. For freeze some tasks, it’s ok to freeze the embedding layer E with initial word2vec values. Freezing means we use word2vec or some other pretraining algorithm to compute the initial embedding matrix E, and then hold it constant while we only modify W, U, and b, i.e., we don’t update E during language model training. However, often we’d like to learn the embeddings simultaneously with training the network. This is useful when the task the network is designed for (like sentiment classification, translation, or parsing) places strong constraints on what makes a good representation for words. Let’s see how to train the entire model including E, i.e. to set all the parameters θ = E,W,U,b. We’ll do this via gradient descent (Fig. ??), using error backpropagation on the computation graph to compute the gradient. Training thus not only sets the weights W and U of the network, but also as we’re predicting upcoming words, we’re learning the embeddings E for each word that best
backpropagation cially for neural networks, it turns out to be the same as a more general procedure called backward differentiation, which depends on the notion of computation graphs. Let’s see how that works in the next subsection. 7.5.3 Computation Graphs A computation graph is a representation of the process of computing a mathematical expression, in which the computation is broken down into separate operations, each of which is modeled as a node in a graph. Consider computing the function L(a,b, c) = c(a+2b). If we make each of the component addition and multiplication operations explicit, and add names (d and e) for the intermediate outputs, the resulting series of computations is: d = 2 ∗ b e = a+d L = c ∗ e We can now represent this as a graph, with nodes for each operation, and directed edges showing the outputs from each operation as the inputs to the next, as in Fig. 7.12. The simplest use of computation graphs is to compute the value of the function with some given inputs. In the figure, we’ve assumed the inputs a = 3, b = 1, c = −2, and we’ve shown the result of the forward pass to compute the result L(3,1,−2) = −10. In the forward pass of a computation graph, we apply each operation left to right, passing the outputs of each computation as the input to the next node. e=a+d d = 2b L=ce a=3 b=1 c=-2 e=5 d=2 L=-10 forward pass a b c Figure 7.12 Computation graph for the function L(a,b, c) = c(a+2b), with values for input nodes a = 3, b = 1, c = −2, showing the forward pass computation of L. 7.5.4 Backward differentiation on computation graphs The importance of the computation graph comes from the backward pass, which is used to compute the derivatives that we’ll need for the weight update. In this example our goal is to compute the derivative of the output function L with respect 7.5 • TRAINING NEURAL NETS 17 to each of the input variables, i.e., ∂L ∂a , ∂L ∂b , and ∂L ∂ c . The derivative ∂L ∂a tells us how much a small change in a affects L. chain rule Backwards differentiation makes use of the chain rule in calculus, so let’s remind ourselves of that. Suppose we are computing the derivative of a composite function f(x) = u(v(x)). The derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x: d f dx = du dv · dv dx (7.29) The chain rule extends to more than two functions. If computing the derivative of a composite function f(x) = u(v(w(x))), the derivative of f(x) is: d f dx = du dv · dv dw · dw dx (7.30) The intuition of backward differentiation is to pass gradients back from the final node to all the nodes in the graph. Fig. 7.13 shows part of the backward computation at

Question:
what is nural network

",Neural network theory relies on learning model from the previous.
Team Neural Narrators,2025-05-22T10:18:39.820800,what is nural network,"[""newData.txt_chunk24"", ""newData.txt_chunk10"", ""newData.txt_chunk20"", ""newData.txt_chunk6"", ""newData.txt_chunk19"", ""newData.txt_chunk25"", ""newData.txt_chunk0"", ""newData.txt_chunk1"", ""newData.txt_chunk22"", ""newData.txt_chunk15""]","You are an expert assistant that only answers questions about quries if the relevant information is available in the given context.
Answer strictly based on the context provided..
Context:
= E,W,U,b. Training the parameters to minimize loss will result both in an algorithm for language modeling (a word predictor) but also a new set of embeddings E that can be used as word representations for other tasks. 7.8 Summary • Neural networks are built out of neural units, originally inspired by biological neurons but now simply an abstract computational device. • Each neural unit multiplies input values by a weight vector, adds a bias, and then applies a non-linear activation function like sigmoid, tanh, or rectified linear unit. • In a fully-connected, feedforward network, each unit in layer i is connected to each unit in layer i+1, and there are no cycles. • The power of neural networks comes from the ability of early layers to learn representations that can be utilized by later layers in the network. • Neural networks are trained by optimization algorithms like gradient descent. • Error backpropagation, backward differentiation on a computation graph, is used to compute the gradients of the loss function for a network. 26 CHAPTER 7 • NEURAL NETWORKS • Neural language models use a neural network as a probabilistic classifier, to compute the probability of the next word given the previous n words. • Neural language models can use pretrained embeddings, or can learn embeddings from scratch in the process of language modeling. Bibliographical and Historical Notes The origins of neural networks lie in the 1940s McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. By the late 1950s and early 1960s, a number of labs (including Frank Rosenblatt at Cornell and Bernard Widrow at Stanford) developed research into neural networks; this phase saw the development of the perceptron (Rosenblatt, 1958), and the transformation of the threshold into a bias, a notation we still use (Widrow and Hoff, 1960). The field of neural networks declined after it was shown that a single perceptron unit was unable to model functions as simple as XOR (Minsky and Papert, 1969). While some small amount of work continued during the next two decades, a major revival for the field didn’t come until the 1980s, when practical tools for building deeper networks like error backpropagation became widespread (Rumelhart et al., 1986). During the 1980s a wide variety of neural network and related architectures were developed, particularly for applications in psychology and cognitive science (Rumelhart and McClelland 1986b, McClelland and Elman 1986, Rumelhart connectionist and McClelland 1986a, Elman 1990), for which the term connectionist or parallel distributed processing was often used (Feldman and Ballard 1982, Smolensky 1988). Many of the principles and techniques developed in this period are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al.
without non-linear activation functions, a multilayer network is just a notational variant of a single layer network with a different set of weights, and we lose all the representational power of multilayer networks. 7.4 • FEEDFORWARD NETWORKS FOR NLP: CLASSIFICATION 11 Replacing the bias unit In describing networks, we will often use a slightly simplified notation that represents exactly the same function without referring to an explicit bias node b. Instead, we add a dummy node a0 to each layer whose value will always be 1. Thus layer 0, the input layer, will have a dummy node a [0] 0 = 1, layer 1 will have a [1] 0 = 1, and so on. This dummy node still has an associated weight, and that weight represents the bias value b. For example instead of an equation like h = σ(Wx+b) (7.15) we’ll use: h = σ(Wx) (7.16) But now instead of our vector x having n0 values: x = x1,...,xn0 , it will have n0 + 1 values, with a new 0th dummy value x0 = 1: x = x0,...,xn0 . And instead of computing each hj as follows: hj = σ Xn0 i=1 Wji xi +bj ! , (7.17) we’ll instead use: hj = σ Xn0 i=0 Wji xi ! , (7.18) where the value Wj0 replaces what had been bj . Fig. 7.9 shows a visualization. x1 x2 xn0 … … +1 b … W U h1 y1 y2 yn2 h2 h3 hn1 x1 x2 xn0 … … x0=1 … W U h1 y1 y2 yn2 h2 h3 hn1 (a) (b) Figure 7.9 Replacing the bias node (shown in a) with x0 (b). We’ll continue showing the bias as b when we go over the learning algorithm in Section 7.5, but then we’ll switch to this simplified notation without explicit bias terms for the rest of the book. 7.4 Feedforward networks for NLP: Classification Let’s see how to apply feedforward networks to NLP tasks! In this section we’ll look at classification tasks like sentiment analysis; in the next section we’ll introduce neural language modeling. 12 CHAPTER 7 • NEURAL NETWORKS Let’s begin with a simple 2-layer sentiment classifier. You might imagine taking our logistic regression classifier from Chapter 5, which corresponds to a 1-layer network, and just adding a hidden layer. The input element xi could be scalar features like those in Fig. ??, e.g., x1 = count(words ∈ doc), x2 = count(positive lexicon words ∈ doc), x3 = 1 if “no” ∈ doc, and so on. And the output layer yˆ could have two nodes (one each for positive and negative), or 3 nodes (positive, negative, neutral), in which case yˆ1 would be the estimated probability of positive sentiment, yˆ2 the probability of negative and yˆ3 the probability of neutral. The resulting equations would be just what we saw above for a 2-layer network (as always, we’ll continue to use the σ to stand for any non-linearity, whether sigmoid, ReLU or other). x = [x1,x2,...xN] (each xi
at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1 previous words: P(wt |w1,...,wt−1) ≈ P(wt |wt−N+1,...,wt−1) (7.42) In the following examples we’ll use a 4-gram example, so we’ll show a neural net to estimate the probability P(wt = i|wt−3,wt−2,wt−1). Neural language models represent words in this prior context by their embeddings, rather than just by their word identity as used in n-gram language models. Using embeddings allows neural language models to generalize better to unseen data. For example, suppose we’ve seen this sentence in training: I have to make sure that the cat gets fed. 22 CHAPTER 7 • NEURAL NETWORKS but have never seen the words “gets fed” after the word “dog”. Our test set has the prefix “I forgot to make sure that the dog gets”. What’s the next word? An n-gram language model will predict “fed” after “that the cat gets”, but not after “that the dog gets”. But a neural LM, knowing that “cat” and “dog” have similar embeddings, will be able to generalize from the “cat” context to assign a high enough probability to “fed” even after seeing “dog”. 7.6.1 Forward inference in the neural language model Let’s walk through forward inference or decoding for neural language models. forward inference Forward inference is the task, given an input, of running a forward pass on the network to produce a probability distribution over possible outputs, in this case next words. We first represent each of the N previous words as a one-hot vector of length one-hot vector |V|, i.e., with one dimension for each word in the vocabulary. A one-hot vector is a vector that has one element equal to 1—in the dimension corresponding to that word’s index in the vocabulary— while all the other elements are set to zero. Thus in a one-hot representation for the word “toothpaste”, supposing it is V5, i.e., index 5 in the vocabulary, x5 = 1, and xi = 0 ∀i 6= 5, as shown here: [0 0 0 0 1 0 0 ... 0 0 0 0] 1 2 3 4 5 6 7 ... ... |V| The feedforward neural language model (sketched in Fig. 7.17) has a moving window that can see N words into the past. We’ll let N equal 3, so the 3 words wt−1, wt−2, and wt−3 are each represented as a one-hot vector. We then multiply these one-hot vectors by the embedding matrix E. The embedding weight matrix E has a column for each word, each a column vector of d dimensions, and hence has dimensionality d × |V|. Multiplying by a one-hot vector that has only one non-zero element xi = 1 simply selects out the relevant column vector for word i, resulting in the embedding for word i, as shown in
from units in each layer are passed to units in the next higher layer, and no outputs are passed back to lower layers. (In Chapter 8 we’ll introduce networks with cycles, called recurrent neural networks.) For historical reasons multilayer networks, especially feedforward networks, are sometimes called multi-layer perceptrons (or MLPs); this is a technical misnomer, multi-layer perceptrons MLP since the units in modern multilayer networks aren’t perceptrons (perceptrons have a simple step-function as their activation function, but modern networks are made up of units with many kinds of non-linearities like ReLUs and sigmoids), but at some point the name stuck. Simple feedforward networks have three kinds of nodes: input units, hidden units, and output units. Fig. 7.8 shows a picture. The input layer x is a vector of simple scalar values just as we saw in Fig. 7.2. The core of the neural network is the hidden layer h formed of hidden units hi hidden layer , each of which is a neural unit as described in Section 7.1, taking a weighted sum of its inputs and then applying a non-linearity. In the standard architecture, each layer fully-connected is fully-connected, meaning that each unit in each layer takes as input the outputs from all the units in the previous layer, and there is a link between every pair of units from two adjacent layers. Thus each hidden unit sums over all the input units. Recall that a single hidden unit has as parameters a weight vector and a bias. We represent the parameters for the entire hidden layer by combining the weight vector and bias for each unit i into a single weight matrix W and a single bias vector b for the whole layer (see Fig. 7.8). Each element Wji of the weight matrix W represents the weight of the connection from the ith input unit xi to the jth hidden unit hj . The advantage of using a single matrix W for the weights of the entire layer is that now the hidden layer computation for a feedforward network can be done very 8 CHAPTER 7 • NEURAL NETWORKS x1 x2 xn0 … … +1 b … W U input layer hidden layer output layer h1 y1 y2 yn2 h2 h3 hn1 Figure 7.8 A simple 2-layer feedforward network, with one hidden layer, one output layer, and one input layer (the input layer is usually not counted when enumerating layers). efficiently with simple matrix operations. In fact, the computation only has three steps: multiplying the weight matrix by the input vector x, adding the bias vector b, and applying the activation function g (such as the sigmoid, tanh, or ReLU activation function defined above). The output of the hidden layer, the vector h, is thus the following (for this example we’ll use the sigmoid function σ as our activation function): h = σ(Wx+b) (7.8) Notice that we’re applying the σ function here to a vector, while in Eq. 7.3 it was applied to a scalar. We’re thus allowing
One of the most dropout important is dropout: randomly dropping some units and their connections from the network during training (Hinton et al. 2012, Srivastava et al. 2014). At each iteration of training (whenever we update parameters, i.e. each mini-batch if we are using mini-batch gradient descent), we repeatedly choose a probability p and for each unit we replace its output with zero with probability p (and renormalize the rest of the outputs from that layer). 7.6 • FEEDFORWARD NEURAL LANGUAGE MODELING 21 hyperparameter Tuning of hyperparameters is also important. The parameters of a neural network are the weights W and biases b; those are learned by gradient descent. The hyperparameters are things that are chosen by the algorithm designer; optimal values are tuned on a devset rather than by gradient descent learning on the training set. Hyperparameters include the learning rate η, the mini-batch size, the model architecture (the number of layers, the number of hidden nodes per layer, the choice of activation functions), how to regularize, and so on. Gradient descent itself also has many architectural variants such as Adam (Kingma and Ba, 2015). Finally, most modern neural networks are built using computation graph formalisms that make it easy and natural to do gradient computation and parallelization on vector-based GPUs (Graphic Processing Units). PyTorch (Paszke et al., 2017) and TensorFlow (Abadi et al., 2015) are two of the most popular. The interested reader should consult a neural network textbook for further details; some suggestions are at the end of the chapter. 7.6 Feedforward Neural Language Modeling As our second application of feedforward networks, let’s consider language modeling: predicting upcoming words from prior words. Neural language modeling— based on the transformer architecture that we will see in Chapter 9—is the algorithm that underlies all of modern NLP. In this section and the next we’ll introduce a simpler version of neural language models for feedforward networks, an algorithm first introduced by Bengio et al. (2003). The feedforward language model introduces many of the important concepts of neural language modeling, concepts we’ll return to as we describe more powerful models in Chapter 8 and Chapter 9. Neural language models have many advantages over the n-gram language models of Chapter 3. Compared to n-gram models, neural language models can handle much longer histories, can generalize better over contexts of similar words, and are more accurate at word-prediction. On the other hand, neural net language models are much more complex, are slower and need more energy to train, and are less interpretable than n-gram models, so for some smaller tasks an n-gram language model is still the right tool. A feedforward neural language model (LM) is a feedforward network that takes as input at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1
are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al. 1989) and speech recognition (Morgan and Bourlard 1990). By the early 2000s, improvements in computer hardware and advances in optimization and training techniques made it possible to train even larger and deeper networks, leading to the modern term deep learning (Hinton et al. 2006, Bengio et al. 2007). We cover more related history in Chapter 8 and Chapter 16. There are a number of excellent books on the subject. Goldberg (2017) has superb coverage of neural networks for natural language processing. For neural networks in general see Goodfellow et al. (2016) and Nielsen (2015). Bibliographical and Historical Notes 27 Abadi, M., A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane, R. Monga, S. Moore, D. Murray, C. Olah, ´ M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Viegas, ´ O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. 2015. TensorFlow: Large-scale machine learning on heterogeneous systems. Software available from tensorflow.org. Bengio, Y., R. Ducharme, P. Vincent, and C. Jauvin. 2003. A neural probabilistic language model. JMLR, 3:1137– 1155. Bengio, Y., P. Lamblin, D. Popovici, and H. Larochelle. 2007. Greedy layer-wise training of deep networks. NeurIPS. Elman, J. L. 1990. Finding structure in time. Cognitive science, 14(2):179–211. Feldman, J. A. and D. H. Ballard. 1982. Connectionist models and their properties. Cognitive Science, 6:205–254. Goldberg, Y. 2017. Neural Network Methods for Natural Language Processing, volume 10 of Synthesis Lectures on Human Language Technologies. Morgan & Claypool. Goodfellow, I., Y. Bengio, and A. Courville. 2016. Deep Learning. MIT Press. Hinton, G. E. 1986. Learning distributed representations of concepts. COGSCI. Hinton, G. E., S. Osindero, and Y.-W. Teh. 2006. A fast learning algorithm for deep belief nets. Neural computation, 18(7):1527–1554. Hinton, G. E., N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov. 2012. Improving neural networks by preventing co-adaptation of feature detectors. ArXiv preprint arXiv:1207.0580. Kingma, D. and J. Ba. 2015. Adam: A method for stochastic optimization. ICLR 2015. LeCun, Y., B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel. 1989. Backpropagation applied to handwritten zip code recognition. Neural computation, 1(4):541–551. McClelland, J. L. and J. L. Elman. 1986. The TRACE model of speech perception. Cognitive Psychology, 18:1–86. McCulloch, W. S. and W. Pitts. 1943. A logical calculus of ideas immanent in nervous activity. Bulletin of Mathematical Biophysics, 5:115–133. Minsky, M. and S. Papert. 1969. Perceptrons. MIT Press. Morgan, N. and H. Bourlard. 1990. Continuous speech recognition using multilayer perceptrons with
Speech and Language Processing. Daniel Jurafsky & James H. Martin. Copyright © 2024. All rights reserved. Draft of January 12, 2025. CHAPTER 7 Neural Networks “[M]achines of this character can behave in a very complicated manner when the number of units is large.” Alan Turing (1948) “Intelligent Machines”, page 6 Neural networks are a fundamental computational tool for language processing, and a very old one. They are called neural because their origins lie in the McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. But the modern use in language processing no longer draws on these early biological inspirations. Instead, a modern neural network is a network of small computing units, each of which takes a vector of input values and produces a single output value. In this chapter we introduce the neural net applied to classification. The architecture we feedforward introduce is called a feedforward network because the computation proceeds iteratively from one layer of units to the next. The use of modern neural nets is often deep learning called deep learning, because modern networks are often deep (have many layers). Neural networks share much of the same mathematics as logistic regression. But neural networks are a more powerful classifier than logistic regression, and indeed a minimal neural network (technically one with a single ‘hidden layer’) can be shown to learn any function. Neural net classifiers are different from logistic regression in another way. With logistic regression, we applied the regression classifier to many different tasks by developing many rich kinds of feature templates based on domain knowledge. When working with neural networks, it is more common to avoid most uses of rich handderived features, instead building neural networks that take raw words as inputs and learn to induce features as part of the process of learning to classify. We saw examples of this kind of representation learning for embeddings in Chapter 6. Nets that are very deep are particularly good at representation learning. For that reason deep neural nets are the right tool for tasks that offer sufficient data to learn features automatically. In this chapter we’ll introduce feedforward networks as classifiers, and also apply them to the simple task of language modeling: assigning probabilities to word sequences and predicting upcoming words. In subsequent chapters we’ll introduce many other aspects of neural models, such as recurrent neural networks (Chapter 8), the Transformer (Chapter 9), and masked language modeling (Chapter 11). 2 CHAPTER 7 • NEURAL NETWORKS 7.1 Units The building block of a neural network is a single computational unit. A unit takes a set of real valued numbers as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of
as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of corresponding weights w1...wn and a bias b, so the weighted sum z can be represented as: z = b+ X i wixi (7.1) Often it’s more convenient to express this weighted sum using vector notation; recall vector from linear algebra that a vector is, at heart, just a list or array of numbers. Thus we’ll talk about z in terms of a weight vector w, a scalar bias b, and an input vector x, and we’ll replace the sum with the convenient dot product: z = w · x+b (7.2) As defined in Eq. 7.2, z is just a real valued number. Finally, instead of using z, a linear function of x, as the output, neural units apply a non-linear function f to z. We will refer to the output of this function as activation the activation value for the unit, a. Since we are just modeling a single unit, the activation for the node is in fact the final output of the network, which we’ll generally call y. So the value y is defined as: y = a = f(z) We’ll discuss three popular non-linear functions f below (the sigmoid, the tanh, and the rectified linear unit or ReLU) but it’s pedagogically convenient to start with the sigmoid sigmoid function since we saw it in Chapter 5: y = σ(z) = 1 1+e −z (7.3) The sigmoid (shown in Fig. 7.1) has a number of advantages; it maps the output into the range (0,1), which is useful in squashing outliers toward 0 or 1. And it’s differentiable, which as we saw in Section ?? will be handy for learning. Figure 7.1 The sigmoid function takes a real value and maps it to the range (0,1). It is nearly linear around 0 but outlier values get squashed toward 0 or 1. Substituting Eq. 7.2 into Eq. 7.3 gives us the output of a neural unit: y = σ(w · x+b) = 1 1+exp(−(w · x+b)) (7.4) 7.1 • UNITS 3 Fig. 7.2 shows a final schematic of a basic neural unit. In this example the unit takes 3 input values x1, x2, and x3, and computes a weighted sum, multiplying each value by a weight (w1, w2, and w3, respectively), adds them to a bias term b, and then passes the resulting sum through a sigmoid function to result in a number between 0 and 1. x1 x2 x3 y w1 w2 w3 ∑ b σ +1 z a Figure 7.2 A neural unit, taking 3 inputs x1, x2, and x3 (and a bias b that we represent as a weight for an input clamped at +1) and producing an output y. We include some convenient intermediate variables: the output
layer for input w will be Exi = ei , the embedding for word i. We now concatenate the three embeddings for the three context words to produce the embedding layer e. 2. Multiply by W: We multiply by W (and add b) and pass through the ReLU (or other) activation function to get the hidden layer h. 3. Multiply by U: h is now multiplied by U 4. Apply softmax: After the softmax, each node i in the output layer estimates the probability P(wt = i|wt−1,wt−2,wt−3) In summary, the equations for a neural language model with a window size of 3, given one-hot input vectors for each input context word, are: e = [Ext−3;Ext−2;Ext−1] h = σ(We+b) z = Uh yˆ = softmax(z) (7.43) Note that we formed the embedding layer e by concatenating the 3 embeddings for the three context vectors; we’ll often use semicolons to mean concatenation of vectors. 24 CHAPTER 7 • NEURAL NETWORKS 7.7 Training the neural language model The high-level intuition of training neural language models, whether the simple feedforward language models we describe here or the more powerful transformer self-training language models of Chapter 9, is the idea of self-training or self-supervision that we saw in Chapter 6 for learning word representations. In self-training for language modeling, we take a corpus of text as training material and at each time step t ask the model to predict the next word. At first it will do poorly at this task, but since in each case we know the correct answer (it’s the next word in the corpus!) we can easily train it to be better at predicting the correct next word. We call such a model self-supervised because we don’t have to add any special gold labels to the data; the natural sequence of words is its own supervision! We simply train the model to minimize the error in predicting the true next word in the training sequence. In practice, training the model means setting the parameters θ = E,W,U,b. For freeze some tasks, it’s ok to freeze the embedding layer E with initial word2vec values. Freezing means we use word2vec or some other pretraining algorithm to compute the initial embedding matrix E, and then hold it constant while we only modify W, U, and b, i.e., we don’t update E during language model training. However, often we’d like to learn the embeddings simultaneously with training the network. This is useful when the task the network is designed for (like sentiment classification, translation, or parsing) places strong constraints on what makes a good representation for words. Let’s see how to train the entire model including E, i.e. to set all the parameters θ = E,W,U,b. We’ll do this via gradient descent (Fig. ??), using error backpropagation on the computation graph to compute the gradient. Training thus not only sets the weights W and U of the network, but also as we’re predicting upcoming words, we’re learning the embeddings E for each word that best
backpropagation cially for neural networks, it turns out to be the same as a more general procedure called backward differentiation, which depends on the notion of computation graphs. Let’s see how that works in the next subsection. 7.5.3 Computation Graphs A computation graph is a representation of the process of computing a mathematical expression, in which the computation is broken down into separate operations, each of which is modeled as a node in a graph. Consider computing the function L(a,b, c) = c(a+2b). If we make each of the component addition and multiplication operations explicit, and add names (d and e) for the intermediate outputs, the resulting series of computations is: d = 2 ∗ b e = a+d L = c ∗ e We can now represent this as a graph, with nodes for each operation, and directed edges showing the outputs from each operation as the inputs to the next, as in Fig. 7.12. The simplest use of computation graphs is to compute the value of the function with some given inputs. In the figure, we’ve assumed the inputs a = 3, b = 1, c = −2, and we’ve shown the result of the forward pass to compute the result L(3,1,−2) = −10. In the forward pass of a computation graph, we apply each operation left to right, passing the outputs of each computation as the input to the next node. e=a+d d = 2b L=ce a=3 b=1 c=-2 e=5 d=2 L=-10 forward pass a b c Figure 7.12 Computation graph for the function L(a,b, c) = c(a+2b), with values for input nodes a = 3, b = 1, c = −2, showing the forward pass computation of L. 7.5.4 Backward differentiation on computation graphs The importance of the computation graph comes from the backward pass, which is used to compute the derivatives that we’ll need for the weight update. In this example our goal is to compute the derivative of the output function L with respect 7.5 • TRAINING NEURAL NETS 17 to each of the input variables, i.e., ∂L ∂a , ∂L ∂b , and ∂L ∂ c . The derivative ∂L ∂a tells us how much a small change in a affects L. chain rule Backwards differentiation makes use of the chain rule in calculus, so let’s remind ourselves of that. Suppose we are computing the derivative of a composite function f(x) = u(v(x)). The derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x: d f dx = du dv · dv dx (7.29) The chain rule extends to more than two functions. If computing the derivative of a composite function f(x) = u(v(w(x))), the derivative of f(x) is: d f dx = du dv · dv dw · dw dx (7.30) The intuition of backward differentiation is to pass gradients back from the final node to all the nodes in the graph. Fig. 7.13 shows part of the backward computation at

Question:
what is nural network

",Neural networks
Team Neural Narrators,2025-05-22T10:23:54.105515,what is nural network,"[""newData.txt_chunk24"", ""newData.txt_chunk10"", ""newData.txt_chunk20"", ""newData.txt_chunk6"", ""newData.txt_chunk19"", ""newData.txt_chunk25"", ""newData.txt_chunk0"", ""newData.txt_chunk1"", ""newData.txt_chunk22"", ""newData.txt_chunk15""]","You are an expert assistant that only answers questions about quries if the relevant information is available in the given context.
Answer strictly based on the context provided..
Context:
= E,W,U,b. Training the parameters to minimize loss will result both in an algorithm for language modeling (a word predictor) but also a new set of embeddings E that can be used as word representations for other tasks. 7.8 Summary • Neural networks are built out of neural units, originally inspired by biological neurons but now simply an abstract computational device. • Each neural unit multiplies input values by a weight vector, adds a bias, and then applies a non-linear activation function like sigmoid, tanh, or rectified linear unit. • In a fully-connected, feedforward network, each unit in layer i is connected to each unit in layer i+1, and there are no cycles. • The power of neural networks comes from the ability of early layers to learn representations that can be utilized by later layers in the network. • Neural networks are trained by optimization algorithms like gradient descent. • Error backpropagation, backward differentiation on a computation graph, is used to compute the gradients of the loss function for a network. 26 CHAPTER 7 • NEURAL NETWORKS • Neural language models use a neural network as a probabilistic classifier, to compute the probability of the next word given the previous n words. • Neural language models can use pretrained embeddings, or can learn embeddings from scratch in the process of language modeling. Bibliographical and Historical Notes The origins of neural networks lie in the 1940s McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. By the late 1950s and early 1960s, a number of labs (including Frank Rosenblatt at Cornell and Bernard Widrow at Stanford) developed research into neural networks; this phase saw the development of the perceptron (Rosenblatt, 1958), and the transformation of the threshold into a bias, a notation we still use (Widrow and Hoff, 1960). The field of neural networks declined after it was shown that a single perceptron unit was unable to model functions as simple as XOR (Minsky and Papert, 1969). While some small amount of work continued during the next two decades, a major revival for the field didn’t come until the 1980s, when practical tools for building deeper networks like error backpropagation became widespread (Rumelhart et al., 1986). During the 1980s a wide variety of neural network and related architectures were developed, particularly for applications in psychology and cognitive science (Rumelhart and McClelland 1986b, McClelland and Elman 1986, Rumelhart connectionist and McClelland 1986a, Elman 1990), for which the term connectionist or parallel distributed processing was often used (Feldman and Ballard 1982, Smolensky 1988). Many of the principles and techniques developed in this period are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al.
without non-linear activation functions, a multilayer network is just a notational variant of a single layer network with a different set of weights, and we lose all the representational power of multilayer networks. 7.4 • FEEDFORWARD NETWORKS FOR NLP: CLASSIFICATION 11 Replacing the bias unit In describing networks, we will often use a slightly simplified notation that represents exactly the same function without referring to an explicit bias node b. Instead, we add a dummy node a0 to each layer whose value will always be 1. Thus layer 0, the input layer, will have a dummy node a [0] 0 = 1, layer 1 will have a [1] 0 = 1, and so on. This dummy node still has an associated weight, and that weight represents the bias value b. For example instead of an equation like h = σ(Wx+b) (7.15) we’ll use: h = σ(Wx) (7.16) But now instead of our vector x having n0 values: x = x1,...,xn0 , it will have n0 + 1 values, with a new 0th dummy value x0 = 1: x = x0,...,xn0 . And instead of computing each hj as follows: hj = σ Xn0 i=1 Wji xi +bj ! , (7.17) we’ll instead use: hj = σ Xn0 i=0 Wji xi ! , (7.18) where the value Wj0 replaces what had been bj . Fig. 7.9 shows a visualization. x1 x2 xn0 … … +1 b … W U h1 y1 y2 yn2 h2 h3 hn1 x1 x2 xn0 … … x0=1 … W U h1 y1 y2 yn2 h2 h3 hn1 (a) (b) Figure 7.9 Replacing the bias node (shown in a) with x0 (b). We’ll continue showing the bias as b when we go over the learning algorithm in Section 7.5, but then we’ll switch to this simplified notation without explicit bias terms for the rest of the book. 7.4 Feedforward networks for NLP: Classification Let’s see how to apply feedforward networks to NLP tasks! In this section we’ll look at classification tasks like sentiment analysis; in the next section we’ll introduce neural language modeling. 12 CHAPTER 7 • NEURAL NETWORKS Let’s begin with a simple 2-layer sentiment classifier. You might imagine taking our logistic regression classifier from Chapter 5, which corresponds to a 1-layer network, and just adding a hidden layer. The input element xi could be scalar features like those in Fig. ??, e.g., x1 = count(words ∈ doc), x2 = count(positive lexicon words ∈ doc), x3 = 1 if “no” ∈ doc, and so on. And the output layer yˆ could have two nodes (one each for positive and negative), or 3 nodes (positive, negative, neutral), in which case yˆ1 would be the estimated probability of positive sentiment, yˆ2 the probability of negative and yˆ3 the probability of neutral. The resulting equations would be just what we saw above for a 2-layer network (as always, we’ll continue to use the σ to stand for any non-linearity, whether sigmoid, ReLU or other). x = [x1,x2,...xN] (each xi
at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1 previous words: P(wt |w1,...,wt−1) ≈ P(wt |wt−N+1,...,wt−1) (7.42) In the following examples we’ll use a 4-gram example, so we’ll show a neural net to estimate the probability P(wt = i|wt−3,wt−2,wt−1). Neural language models represent words in this prior context by their embeddings, rather than just by their word identity as used in n-gram language models. Using embeddings allows neural language models to generalize better to unseen data. For example, suppose we’ve seen this sentence in training: I have to make sure that the cat gets fed. 22 CHAPTER 7 • NEURAL NETWORKS but have never seen the words “gets fed” after the word “dog”. Our test set has the prefix “I forgot to make sure that the dog gets”. What’s the next word? An n-gram language model will predict “fed” after “that the cat gets”, but not after “that the dog gets”. But a neural LM, knowing that “cat” and “dog” have similar embeddings, will be able to generalize from the “cat” context to assign a high enough probability to “fed” even after seeing “dog”. 7.6.1 Forward inference in the neural language model Let’s walk through forward inference or decoding for neural language models. forward inference Forward inference is the task, given an input, of running a forward pass on the network to produce a probability distribution over possible outputs, in this case next words. We first represent each of the N previous words as a one-hot vector of length one-hot vector |V|, i.e., with one dimension for each word in the vocabulary. A one-hot vector is a vector that has one element equal to 1—in the dimension corresponding to that word’s index in the vocabulary— while all the other elements are set to zero. Thus in a one-hot representation for the word “toothpaste”, supposing it is V5, i.e., index 5 in the vocabulary, x5 = 1, and xi = 0 ∀i 6= 5, as shown here: [0 0 0 0 1 0 0 ... 0 0 0 0] 1 2 3 4 5 6 7 ... ... |V| The feedforward neural language model (sketched in Fig. 7.17) has a moving window that can see N words into the past. We’ll let N equal 3, so the 3 words wt−1, wt−2, and wt−3 are each represented as a one-hot vector. We then multiply these one-hot vectors by the embedding matrix E. The embedding weight matrix E has a column for each word, each a column vector of d dimensions, and hence has dimensionality d × |V|. Multiplying by a one-hot vector that has only one non-zero element xi = 1 simply selects out the relevant column vector for word i, resulting in the embedding for word i, as shown in
from units in each layer are passed to units in the next higher layer, and no outputs are passed back to lower layers. (In Chapter 8 we’ll introduce networks with cycles, called recurrent neural networks.) For historical reasons multilayer networks, especially feedforward networks, are sometimes called multi-layer perceptrons (or MLPs); this is a technical misnomer, multi-layer perceptrons MLP since the units in modern multilayer networks aren’t perceptrons (perceptrons have a simple step-function as their activation function, but modern networks are made up of units with many kinds of non-linearities like ReLUs and sigmoids), but at some point the name stuck. Simple feedforward networks have three kinds of nodes: input units, hidden units, and output units. Fig. 7.8 shows a picture. The input layer x is a vector of simple scalar values just as we saw in Fig. 7.2. The core of the neural network is the hidden layer h formed of hidden units hi hidden layer , each of which is a neural unit as described in Section 7.1, taking a weighted sum of its inputs and then applying a non-linearity. In the standard architecture, each layer fully-connected is fully-connected, meaning that each unit in each layer takes as input the outputs from all the units in the previous layer, and there is a link between every pair of units from two adjacent layers. Thus each hidden unit sums over all the input units. Recall that a single hidden unit has as parameters a weight vector and a bias. We represent the parameters for the entire hidden layer by combining the weight vector and bias for each unit i into a single weight matrix W and a single bias vector b for the whole layer (see Fig. 7.8). Each element Wji of the weight matrix W represents the weight of the connection from the ith input unit xi to the jth hidden unit hj . The advantage of using a single matrix W for the weights of the entire layer is that now the hidden layer computation for a feedforward network can be done very 8 CHAPTER 7 • NEURAL NETWORKS x1 x2 xn0 … … +1 b … W U input layer hidden layer output layer h1 y1 y2 yn2 h2 h3 hn1 Figure 7.8 A simple 2-layer feedforward network, with one hidden layer, one output layer, and one input layer (the input layer is usually not counted when enumerating layers). efficiently with simple matrix operations. In fact, the computation only has three steps: multiplying the weight matrix by the input vector x, adding the bias vector b, and applying the activation function g (such as the sigmoid, tanh, or ReLU activation function defined above). The output of the hidden layer, the vector h, is thus the following (for this example we’ll use the sigmoid function σ as our activation function): h = σ(Wx+b) (7.8) Notice that we’re applying the σ function here to a vector, while in Eq. 7.3 it was applied to a scalar. We’re thus allowing
One of the most dropout important is dropout: randomly dropping some units and their connections from the network during training (Hinton et al. 2012, Srivastava et al. 2014). At each iteration of training (whenever we update parameters, i.e. each mini-batch if we are using mini-batch gradient descent), we repeatedly choose a probability p and for each unit we replace its output with zero with probability p (and renormalize the rest of the outputs from that layer). 7.6 • FEEDFORWARD NEURAL LANGUAGE MODELING 21 hyperparameter Tuning of hyperparameters is also important. The parameters of a neural network are the weights W and biases b; those are learned by gradient descent. The hyperparameters are things that are chosen by the algorithm designer; optimal values are tuned on a devset rather than by gradient descent learning on the training set. Hyperparameters include the learning rate η, the mini-batch size, the model architecture (the number of layers, the number of hidden nodes per layer, the choice of activation functions), how to regularize, and so on. Gradient descent itself also has many architectural variants such as Adam (Kingma and Ba, 2015). Finally, most modern neural networks are built using computation graph formalisms that make it easy and natural to do gradient computation and parallelization on vector-based GPUs (Graphic Processing Units). PyTorch (Paszke et al., 2017) and TensorFlow (Abadi et al., 2015) are two of the most popular. The interested reader should consult a neural network textbook for further details; some suggestions are at the end of the chapter. 7.6 Feedforward Neural Language Modeling As our second application of feedforward networks, let’s consider language modeling: predicting upcoming words from prior words. Neural language modeling— based on the transformer architecture that we will see in Chapter 9—is the algorithm that underlies all of modern NLP. In this section and the next we’ll introduce a simpler version of neural language models for feedforward networks, an algorithm first introduced by Bengio et al. (2003). The feedforward language model introduces many of the important concepts of neural language modeling, concepts we’ll return to as we describe more powerful models in Chapter 8 and Chapter 9. Neural language models have many advantages over the n-gram language models of Chapter 3. Compared to n-gram models, neural language models can handle much longer histories, can generalize better over contexts of similar words, and are more accurate at word-prediction. On the other hand, neural net language models are much more complex, are slower and need more energy to train, and are less interpretable than n-gram models, so for some smaller tasks an n-gram language model is still the right tool. A feedforward neural language model (LM) is a feedforward network that takes as input at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1
are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al. 1989) and speech recognition (Morgan and Bourlard 1990). By the early 2000s, improvements in computer hardware and advances in optimization and training techniques made it possible to train even larger and deeper networks, leading to the modern term deep learning (Hinton et al. 2006, Bengio et al. 2007). We cover more related history in Chapter 8 and Chapter 16. There are a number of excellent books on the subject. Goldberg (2017) has superb coverage of neural networks for natural language processing. For neural networks in general see Goodfellow et al. (2016) and Nielsen (2015). Bibliographical and Historical Notes 27 Abadi, M., A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane, R. Monga, S. Moore, D. Murray, C. Olah, ´ M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Viegas, ´ O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. 2015. TensorFlow: Large-scale machine learning on heterogeneous systems. Software available from tensorflow.org. Bengio, Y., R. Ducharme, P. Vincent, and C. Jauvin. 2003. A neural probabilistic language model. JMLR, 3:1137– 1155. Bengio, Y., P. Lamblin, D. Popovici, and H. Larochelle. 2007. Greedy layer-wise training of deep networks. NeurIPS. Elman, J. L. 1990. Finding structure in time. Cognitive science, 14(2):179–211. Feldman, J. A. and D. H. Ballard. 1982. Connectionist models and their properties. Cognitive Science, 6:205–254. Goldberg, Y. 2017. Neural Network Methods for Natural Language Processing, volume 10 of Synthesis Lectures on Human Language Technologies. Morgan & Claypool. Goodfellow, I., Y. Bengio, and A. Courville. 2016. Deep Learning. MIT Press. Hinton, G. E. 1986. Learning distributed representations of concepts. COGSCI. Hinton, G. E., S. Osindero, and Y.-W. Teh. 2006. A fast learning algorithm for deep belief nets. Neural computation, 18(7):1527–1554. Hinton, G. E., N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov. 2012. Improving neural networks by preventing co-adaptation of feature detectors. ArXiv preprint arXiv:1207.0580. Kingma, D. and J. Ba. 2015. Adam: A method for stochastic optimization. ICLR 2015. LeCun, Y., B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel. 1989. Backpropagation applied to handwritten zip code recognition. Neural computation, 1(4):541–551. McClelland, J. L. and J. L. Elman. 1986. The TRACE model of speech perception. Cognitive Psychology, 18:1–86. McCulloch, W. S. and W. Pitts. 1943. A logical calculus of ideas immanent in nervous activity. Bulletin of Mathematical Biophysics, 5:115–133. Minsky, M. and S. Papert. 1969. Perceptrons. MIT Press. Morgan, N. and H. Bourlard. 1990. Continuous speech recognition using multilayer perceptrons with
Speech and Language Processing. Daniel Jurafsky & James H. Martin. Copyright © 2024. All rights reserved. Draft of January 12, 2025. CHAPTER 7 Neural Networks “[M]achines of this character can behave in a very complicated manner when the number of units is large.” Alan Turing (1948) “Intelligent Machines”, page 6 Neural networks are a fundamental computational tool for language processing, and a very old one. They are called neural because their origins lie in the McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. But the modern use in language processing no longer draws on these early biological inspirations. Instead, a modern neural network is a network of small computing units, each of which takes a vector of input values and produces a single output value. In this chapter we introduce the neural net applied to classification. The architecture we feedforward introduce is called a feedforward network because the computation proceeds iteratively from one layer of units to the next. The use of modern neural nets is often deep learning called deep learning, because modern networks are often deep (have many layers). Neural networks share much of the same mathematics as logistic regression. But neural networks are a more powerful classifier than logistic regression, and indeed a minimal neural network (technically one with a single ‘hidden layer’) can be shown to learn any function. Neural net classifiers are different from logistic regression in another way. With logistic regression, we applied the regression classifier to many different tasks by developing many rich kinds of feature templates based on domain knowledge. When working with neural networks, it is more common to avoid most uses of rich handderived features, instead building neural networks that take raw words as inputs and learn to induce features as part of the process of learning to classify. We saw examples of this kind of representation learning for embeddings in Chapter 6. Nets that are very deep are particularly good at representation learning. For that reason deep neural nets are the right tool for tasks that offer sufficient data to learn features automatically. In this chapter we’ll introduce feedforward networks as classifiers, and also apply them to the simple task of language modeling: assigning probabilities to word sequences and predicting upcoming words. In subsequent chapters we’ll introduce many other aspects of neural models, such as recurrent neural networks (Chapter 8), the Transformer (Chapter 9), and masked language modeling (Chapter 11). 2 CHAPTER 7 • NEURAL NETWORKS 7.1 Units The building block of a neural network is a single computational unit. A unit takes a set of real valued numbers as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of
as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of corresponding weights w1...wn and a bias b, so the weighted sum z can be represented as: z = b+ X i wixi (7.1) Often it’s more convenient to express this weighted sum using vector notation; recall vector from linear algebra that a vector is, at heart, just a list or array of numbers. Thus we’ll talk about z in terms of a weight vector w, a scalar bias b, and an input vector x, and we’ll replace the sum with the convenient dot product: z = w · x+b (7.2) As defined in Eq. 7.2, z is just a real valued number. Finally, instead of using z, a linear function of x, as the output, neural units apply a non-linear function f to z. We will refer to the output of this function as activation the activation value for the unit, a. Since we are just modeling a single unit, the activation for the node is in fact the final output of the network, which we’ll generally call y. So the value y is defined as: y = a = f(z) We’ll discuss three popular non-linear functions f below (the sigmoid, the tanh, and the rectified linear unit or ReLU) but it’s pedagogically convenient to start with the sigmoid sigmoid function since we saw it in Chapter 5: y = σ(z) = 1 1+e −z (7.3) The sigmoid (shown in Fig. 7.1) has a number of advantages; it maps the output into the range (0,1), which is useful in squashing outliers toward 0 or 1. And it’s differentiable, which as we saw in Section ?? will be handy for learning. Figure 7.1 The sigmoid function takes a real value and maps it to the range (0,1). It is nearly linear around 0 but outlier values get squashed toward 0 or 1. Substituting Eq. 7.2 into Eq. 7.3 gives us the output of a neural unit: y = σ(w · x+b) = 1 1+exp(−(w · x+b)) (7.4) 7.1 • UNITS 3 Fig. 7.2 shows a final schematic of a basic neural unit. In this example the unit takes 3 input values x1, x2, and x3, and computes a weighted sum, multiplying each value by a weight (w1, w2, and w3, respectively), adds them to a bias term b, and then passes the resulting sum through a sigmoid function to result in a number between 0 and 1. x1 x2 x3 y w1 w2 w3 ∑ b σ +1 z a Figure 7.2 A neural unit, taking 3 inputs x1, x2, and x3 (and a bias b that we represent as a weight for an input clamped at +1) and producing an output y. We include some convenient intermediate variables: the output
layer for input w will be Exi = ei , the embedding for word i. We now concatenate the three embeddings for the three context words to produce the embedding layer e. 2. Multiply by W: We multiply by W (and add b) and pass through the ReLU (or other) activation function to get the hidden layer h. 3. Multiply by U: h is now multiplied by U 4. Apply softmax: After the softmax, each node i in the output layer estimates the probability P(wt = i|wt−1,wt−2,wt−3) In summary, the equations for a neural language model with a window size of 3, given one-hot input vectors for each input context word, are: e = [Ext−3;Ext−2;Ext−1] h = σ(We+b) z = Uh yˆ = softmax(z) (7.43) Note that we formed the embedding layer e by concatenating the 3 embeddings for the three context vectors; we’ll often use semicolons to mean concatenation of vectors. 24 CHAPTER 7 • NEURAL NETWORKS 7.7 Training the neural language model The high-level intuition of training neural language models, whether the simple feedforward language models we describe here or the more powerful transformer self-training language models of Chapter 9, is the idea of self-training or self-supervision that we saw in Chapter 6 for learning word representations. In self-training for language modeling, we take a corpus of text as training material and at each time step t ask the model to predict the next word. At first it will do poorly at this task, but since in each case we know the correct answer (it’s the next word in the corpus!) we can easily train it to be better at predicting the correct next word. We call such a model self-supervised because we don’t have to add any special gold labels to the data; the natural sequence of words is its own supervision! We simply train the model to minimize the error in predicting the true next word in the training sequence. In practice, training the model means setting the parameters θ = E,W,U,b. For freeze some tasks, it’s ok to freeze the embedding layer E with initial word2vec values. Freezing means we use word2vec or some other pretraining algorithm to compute the initial embedding matrix E, and then hold it constant while we only modify W, U, and b, i.e., we don’t update E during language model training. However, often we’d like to learn the embeddings simultaneously with training the network. This is useful when the task the network is designed for (like sentiment classification, translation, or parsing) places strong constraints on what makes a good representation for words. Let’s see how to train the entire model including E, i.e. to set all the parameters θ = E,W,U,b. We’ll do this via gradient descent (Fig. ??), using error backpropagation on the computation graph to compute the gradient. Training thus not only sets the weights W and U of the network, but also as we’re predicting upcoming words, we’re learning the embeddings E for each word that best
backpropagation cially for neural networks, it turns out to be the same as a more general procedure called backward differentiation, which depends on the notion of computation graphs. Let’s see how that works in the next subsection. 7.5.3 Computation Graphs A computation graph is a representation of the process of computing a mathematical expression, in which the computation is broken down into separate operations, each of which is modeled as a node in a graph. Consider computing the function L(a,b, c) = c(a+2b). If we make each of the component addition and multiplication operations explicit, and add names (d and e) for the intermediate outputs, the resulting series of computations is: d = 2 ∗ b e = a+d L = c ∗ e We can now represent this as a graph, with nodes for each operation, and directed edges showing the outputs from each operation as the inputs to the next, as in Fig. 7.12. The simplest use of computation graphs is to compute the value of the function with some given inputs. In the figure, we’ve assumed the inputs a = 3, b = 1, c = −2, and we’ve shown the result of the forward pass to compute the result L(3,1,−2) = −10. In the forward pass of a computation graph, we apply each operation left to right, passing the outputs of each computation as the input to the next node. e=a+d d = 2b L=ce a=3 b=1 c=-2 e=5 d=2 L=-10 forward pass a b c Figure 7.12 Computation graph for the function L(a,b, c) = c(a+2b), with values for input nodes a = 3, b = 1, c = −2, showing the forward pass computation of L. 7.5.4 Backward differentiation on computation graphs The importance of the computation graph comes from the backward pass, which is used to compute the derivatives that we’ll need for the weight update. In this example our goal is to compute the derivative of the output function L with respect 7.5 • TRAINING NEURAL NETS 17 to each of the input variables, i.e., ∂L ∂a , ∂L ∂b , and ∂L ∂ c . The derivative ∂L ∂a tells us how much a small change in a affects L. chain rule Backwards differentiation makes use of the chain rule in calculus, so let’s remind ourselves of that. Suppose we are computing the derivative of a composite function f(x) = u(v(x)). The derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x: d f dx = du dv · dv dx (7.29) The chain rule extends to more than two functions. If computing the derivative of a composite function f(x) = u(v(w(x))), the derivative of f(x) is: d f dx = du dv · dv dw · dw dx (7.30) The intuition of backward differentiation is to pass gradients back from the final node to all the nodes in the graph. Fig. 7.13 shows part of the backward computation at

Question:
what is nural network

",is a field of computational science that studies the dynamics of computation.
Team Neural Narrators,2025-05-22T10:36:31.571122,what is nural network,"[""newData.txt_chunk24"", ""newData.txt_chunk10"", ""newData.txt_chunk20"", ""newData.txt_chunk6"", ""newData.txt_chunk19"", ""newData.txt_chunk25"", ""newData.txt_chunk0"", ""newData.txt_chunk1"", ""newData.txt_chunk22"", ""newData.txt_chunk15""]","You are an expert assistant that only answers questions about quries if the relevant information is available in the given context.
Answer strictly based on the context provided..
Context:
= E,W,U,b. Training the parameters to minimize loss will result both in an algorithm for language modeling (a word predictor) but also a new set of embeddings E that can be used as word representations for other tasks. 7.8 Summary • Neural networks are built out of neural units, originally inspired by biological neurons but now simply an abstract computational device. • Each neural unit multiplies input values by a weight vector, adds a bias, and then applies a non-linear activation function like sigmoid, tanh, or rectified linear unit. • In a fully-connected, feedforward network, each unit in layer i is connected to each unit in layer i+1, and there are no cycles. • The power of neural networks comes from the ability of early layers to learn representations that can be utilized by later layers in the network. • Neural networks are trained by optimization algorithms like gradient descent. • Error backpropagation, backward differentiation on a computation graph, is used to compute the gradients of the loss function for a network. 26 CHAPTER 7 • NEURAL NETWORKS • Neural language models use a neural network as a probabilistic classifier, to compute the probability of the next word given the previous n words. • Neural language models can use pretrained embeddings, or can learn embeddings from scratch in the process of language modeling. Bibliographical and Historical Notes The origins of neural networks lie in the 1940s McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. By the late 1950s and early 1960s, a number of labs (including Frank Rosenblatt at Cornell and Bernard Widrow at Stanford) developed research into neural networks; this phase saw the development of the perceptron (Rosenblatt, 1958), and the transformation of the threshold into a bias, a notation we still use (Widrow and Hoff, 1960). The field of neural networks declined after it was shown that a single perceptron unit was unable to model functions as simple as XOR (Minsky and Papert, 1969). While some small amount of work continued during the next two decades, a major revival for the field didn’t come until the 1980s, when practical tools for building deeper networks like error backpropagation became widespread (Rumelhart et al., 1986). During the 1980s a wide variety of neural network and related architectures were developed, particularly for applications in psychology and cognitive science (Rumelhart and McClelland 1986b, McClelland and Elman 1986, Rumelhart connectionist and McClelland 1986a, Elman 1990), for which the term connectionist or parallel distributed processing was often used (Feldman and Ballard 1982, Smolensky 1988). Many of the principles and techniques developed in this period are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al.
without non-linear activation functions, a multilayer network is just a notational variant of a single layer network with a different set of weights, and we lose all the representational power of multilayer networks. 7.4 • FEEDFORWARD NETWORKS FOR NLP: CLASSIFICATION 11 Replacing the bias unit In describing networks, we will often use a slightly simplified notation that represents exactly the same function without referring to an explicit bias node b. Instead, we add a dummy node a0 to each layer whose value will always be 1. Thus layer 0, the input layer, will have a dummy node a [0] 0 = 1, layer 1 will have a [1] 0 = 1, and so on. This dummy node still has an associated weight, and that weight represents the bias value b. For example instead of an equation like h = σ(Wx+b) (7.15) we’ll use: h = σ(Wx) (7.16) But now instead of our vector x having n0 values: x = x1,...,xn0 , it will have n0 + 1 values, with a new 0th dummy value x0 = 1: x = x0,...,xn0 . And instead of computing each hj as follows: hj = σ Xn0 i=1 Wji xi +bj ! , (7.17) we’ll instead use: hj = σ Xn0 i=0 Wji xi ! , (7.18) where the value Wj0 replaces what had been bj . Fig. 7.9 shows a visualization. x1 x2 xn0 … … +1 b … W U h1 y1 y2 yn2 h2 h3 hn1 x1 x2 xn0 … … x0=1 … W U h1 y1 y2 yn2 h2 h3 hn1 (a) (b) Figure 7.9 Replacing the bias node (shown in a) with x0 (b). We’ll continue showing the bias as b when we go over the learning algorithm in Section 7.5, but then we’ll switch to this simplified notation without explicit bias terms for the rest of the book. 7.4 Feedforward networks for NLP: Classification Let’s see how to apply feedforward networks to NLP tasks! In this section we’ll look at classification tasks like sentiment analysis; in the next section we’ll introduce neural language modeling. 12 CHAPTER 7 • NEURAL NETWORKS Let’s begin with a simple 2-layer sentiment classifier. You might imagine taking our logistic regression classifier from Chapter 5, which corresponds to a 1-layer network, and just adding a hidden layer. The input element xi could be scalar features like those in Fig. ??, e.g., x1 = count(words ∈ doc), x2 = count(positive lexicon words ∈ doc), x3 = 1 if “no” ∈ doc, and so on. And the output layer yˆ could have two nodes (one each for positive and negative), or 3 nodes (positive, negative, neutral), in which case yˆ1 would be the estimated probability of positive sentiment, yˆ2 the probability of negative and yˆ3 the probability of neutral. The resulting equations would be just what we saw above for a 2-layer network (as always, we’ll continue to use the σ to stand for any non-linearity, whether sigmoid, ReLU or other). x = [x1,x2,...xN] (each xi
at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1 previous words: P(wt |w1,...,wt−1) ≈ P(wt |wt−N+1,...,wt−1) (7.42) In the following examples we’ll use a 4-gram example, so we’ll show a neural net to estimate the probability P(wt = i|wt−3,wt−2,wt−1). Neural language models represent words in this prior context by their embeddings, rather than just by their word identity as used in n-gram language models. Using embeddings allows neural language models to generalize better to unseen data. For example, suppose we’ve seen this sentence in training: I have to make sure that the cat gets fed. 22 CHAPTER 7 • NEURAL NETWORKS but have never seen the words “gets fed” after the word “dog”. Our test set has the prefix “I forgot to make sure that the dog gets”. What’s the next word? An n-gram language model will predict “fed” after “that the cat gets”, but not after “that the dog gets”. But a neural LM, knowing that “cat” and “dog” have similar embeddings, will be able to generalize from the “cat” context to assign a high enough probability to “fed” even after seeing “dog”. 7.6.1 Forward inference in the neural language model Let’s walk through forward inference or decoding for neural language models. forward inference Forward inference is the task, given an input, of running a forward pass on the network to produce a probability distribution over possible outputs, in this case next words. We first represent each of the N previous words as a one-hot vector of length one-hot vector |V|, i.e., with one dimension for each word in the vocabulary. A one-hot vector is a vector that has one element equal to 1—in the dimension corresponding to that word’s index in the vocabulary— while all the other elements are set to zero. Thus in a one-hot representation for the word “toothpaste”, supposing it is V5, i.e., index 5 in the vocabulary, x5 = 1, and xi = 0 ∀i 6= 5, as shown here: [0 0 0 0 1 0 0 ... 0 0 0 0] 1 2 3 4 5 6 7 ... ... |V| The feedforward neural language model (sketched in Fig. 7.17) has a moving window that can see N words into the past. We’ll let N equal 3, so the 3 words wt−1, wt−2, and wt−3 are each represented as a one-hot vector. We then multiply these one-hot vectors by the embedding matrix E. The embedding weight matrix E has a column for each word, each a column vector of d dimensions, and hence has dimensionality d × |V|. Multiplying by a one-hot vector that has only one non-zero element xi = 1 simply selects out the relevant column vector for word i, resulting in the embedding for word i, as shown in
from units in each layer are passed to units in the next higher layer, and no outputs are passed back to lower layers. (In Chapter 8 we’ll introduce networks with cycles, called recurrent neural networks.) For historical reasons multilayer networks, especially feedforward networks, are sometimes called multi-layer perceptrons (or MLPs); this is a technical misnomer, multi-layer perceptrons MLP since the units in modern multilayer networks aren’t perceptrons (perceptrons have a simple step-function as their activation function, but modern networks are made up of units with many kinds of non-linearities like ReLUs and sigmoids), but at some point the name stuck. Simple feedforward networks have three kinds of nodes: input units, hidden units, and output units. Fig. 7.8 shows a picture. The input layer x is a vector of simple scalar values just as we saw in Fig. 7.2. The core of the neural network is the hidden layer h formed of hidden units hi hidden layer , each of which is a neural unit as described in Section 7.1, taking a weighted sum of its inputs and then applying a non-linearity. In the standard architecture, each layer fully-connected is fully-connected, meaning that each unit in each layer takes as input the outputs from all the units in the previous layer, and there is a link between every pair of units from two adjacent layers. Thus each hidden unit sums over all the input units. Recall that a single hidden unit has as parameters a weight vector and a bias. We represent the parameters for the entire hidden layer by combining the weight vector and bias for each unit i into a single weight matrix W and a single bias vector b for the whole layer (see Fig. 7.8). Each element Wji of the weight matrix W represents the weight of the connection from the ith input unit xi to the jth hidden unit hj . The advantage of using a single matrix W for the weights of the entire layer is that now the hidden layer computation for a feedforward network can be done very 8 CHAPTER 7 • NEURAL NETWORKS x1 x2 xn0 … … +1 b … W U input layer hidden layer output layer h1 y1 y2 yn2 h2 h3 hn1 Figure 7.8 A simple 2-layer feedforward network, with one hidden layer, one output layer, and one input layer (the input layer is usually not counted when enumerating layers). efficiently with simple matrix operations. In fact, the computation only has three steps: multiplying the weight matrix by the input vector x, adding the bias vector b, and applying the activation function g (such as the sigmoid, tanh, or ReLU activation function defined above). The output of the hidden layer, the vector h, is thus the following (for this example we’ll use the sigmoid function σ as our activation function): h = σ(Wx+b) (7.8) Notice that we’re applying the σ function here to a vector, while in Eq. 7.3 it was applied to a scalar. We’re thus allowing
One of the most dropout important is dropout: randomly dropping some units and their connections from the network during training (Hinton et al. 2012, Srivastava et al. 2014). At each iteration of training (whenever we update parameters, i.e. each mini-batch if we are using mini-batch gradient descent), we repeatedly choose a probability p and for each unit we replace its output with zero with probability p (and renormalize the rest of the outputs from that layer). 7.6 • FEEDFORWARD NEURAL LANGUAGE MODELING 21 hyperparameter Tuning of hyperparameters is also important. The parameters of a neural network are the weights W and biases b; those are learned by gradient descent. The hyperparameters are things that are chosen by the algorithm designer; optimal values are tuned on a devset rather than by gradient descent learning on the training set. Hyperparameters include the learning rate η, the mini-batch size, the model architecture (the number of layers, the number of hidden nodes per layer, the choice of activation functions), how to regularize, and so on. Gradient descent itself also has many architectural variants such as Adam (Kingma and Ba, 2015). Finally, most modern neural networks are built using computation graph formalisms that make it easy and natural to do gradient computation and parallelization on vector-based GPUs (Graphic Processing Units). PyTorch (Paszke et al., 2017) and TensorFlow (Abadi et al., 2015) are two of the most popular. The interested reader should consult a neural network textbook for further details; some suggestions are at the end of the chapter. 7.6 Feedforward Neural Language Modeling As our second application of feedforward networks, let’s consider language modeling: predicting upcoming words from prior words. Neural language modeling— based on the transformer architecture that we will see in Chapter 9—is the algorithm that underlies all of modern NLP. In this section and the next we’ll introduce a simpler version of neural language models for feedforward networks, an algorithm first introduced by Bengio et al. (2003). The feedforward language model introduces many of the important concepts of neural language modeling, concepts we’ll return to as we describe more powerful models in Chapter 8 and Chapter 9. Neural language models have many advantages over the n-gram language models of Chapter 3. Compared to n-gram models, neural language models can handle much longer histories, can generalize better over contexts of similar words, and are more accurate at word-prediction. On the other hand, neural net language models are much more complex, are slower and need more energy to train, and are less interpretable than n-gram models, so for some smaller tasks an n-gram language model is still the right tool. A feedforward neural language model (LM) is a feedforward network that takes as input at time t a representation of some number of previous words (wt−1,wt−2, etc.) and outputs a probability distribution over possible next words. Thus—like the n-gram LM—the feedforward neural LM approximates the probability of a word given the entire prior context P(wt |w1:t−1) by approximating based on the N − 1
are foundational to modern work, including the ideas of distributed representations (Hinton, 1986), recurrent networks (Elman, 1990), and the use of tensors for compositionality (Smolensky, 1990). By the 1990s larger neural networks began to be applied to many practical language processing tasks as well, like handwriting recognition (LeCun et al. 1989) and speech recognition (Morgan and Bourlard 1990). By the early 2000s, improvements in computer hardware and advances in optimization and training techniques made it possible to train even larger and deeper networks, leading to the modern term deep learning (Hinton et al. 2006, Bengio et al. 2007). We cover more related history in Chapter 8 and Chapter 16. There are a number of excellent books on the subject. Goldberg (2017) has superb coverage of neural networks for natural language processing. For neural networks in general see Goodfellow et al. (2016) and Nielsen (2015). Bibliographical and Historical Notes 27 Abadi, M., A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane, R. Monga, S. Moore, D. Murray, C. Olah, ´ M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Viegas, ´ O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng. 2015. TensorFlow: Large-scale machine learning on heterogeneous systems. Software available from tensorflow.org. Bengio, Y., R. Ducharme, P. Vincent, and C. Jauvin. 2003. A neural probabilistic language model. JMLR, 3:1137– 1155. Bengio, Y., P. Lamblin, D. Popovici, and H. Larochelle. 2007. Greedy layer-wise training of deep networks. NeurIPS. Elman, J. L. 1990. Finding structure in time. Cognitive science, 14(2):179–211. Feldman, J. A. and D. H. Ballard. 1982. Connectionist models and their properties. Cognitive Science, 6:205–254. Goldberg, Y. 2017. Neural Network Methods for Natural Language Processing, volume 10 of Synthesis Lectures on Human Language Technologies. Morgan & Claypool. Goodfellow, I., Y. Bengio, and A. Courville. 2016. Deep Learning. MIT Press. Hinton, G. E. 1986. Learning distributed representations of concepts. COGSCI. Hinton, G. E., S. Osindero, and Y.-W. Teh. 2006. A fast learning algorithm for deep belief nets. Neural computation, 18(7):1527–1554. Hinton, G. E., N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov. 2012. Improving neural networks by preventing co-adaptation of feature detectors. ArXiv preprint arXiv:1207.0580. Kingma, D. and J. Ba. 2015. Adam: A method for stochastic optimization. ICLR 2015. LeCun, Y., B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel. 1989. Backpropagation applied to handwritten zip code recognition. Neural computation, 1(4):541–551. McClelland, J. L. and J. L. Elman. 1986. The TRACE model of speech perception. Cognitive Psychology, 18:1–86. McCulloch, W. S. and W. Pitts. 1943. A logical calculus of ideas immanent in nervous activity. Bulletin of Mathematical Biophysics, 5:115–133. Minsky, M. and S. Papert. 1969. Perceptrons. MIT Press. Morgan, N. and H. Bourlard. 1990. Continuous speech recognition using multilayer perceptrons with
Speech and Language Processing. Daniel Jurafsky & James H. Martin. Copyright © 2024. All rights reserved. Draft of January 12, 2025. CHAPTER 7 Neural Networks “[M]achines of this character can behave in a very complicated manner when the number of units is large.” Alan Turing (1948) “Intelligent Machines”, page 6 Neural networks are a fundamental computational tool for language processing, and a very old one. They are called neural because their origins lie in the McCulloch-Pitts neuron (McCulloch and Pitts, 1943), a simplified model of the biological neuron as a kind of computing element that could be described in terms of propositional logic. But the modern use in language processing no longer draws on these early biological inspirations. Instead, a modern neural network is a network of small computing units, each of which takes a vector of input values and produces a single output value. In this chapter we introduce the neural net applied to classification. The architecture we feedforward introduce is called a feedforward network because the computation proceeds iteratively from one layer of units to the next. The use of modern neural nets is often deep learning called deep learning, because modern networks are often deep (have many layers). Neural networks share much of the same mathematics as logistic regression. But neural networks are a more powerful classifier than logistic regression, and indeed a minimal neural network (technically one with a single ‘hidden layer’) can be shown to learn any function. Neural net classifiers are different from logistic regression in another way. With logistic regression, we applied the regression classifier to many different tasks by developing many rich kinds of feature templates based on domain knowledge. When working with neural networks, it is more common to avoid most uses of rich handderived features, instead building neural networks that take raw words as inputs and learn to induce features as part of the process of learning to classify. We saw examples of this kind of representation learning for embeddings in Chapter 6. Nets that are very deep are particularly good at representation learning. For that reason deep neural nets are the right tool for tasks that offer sufficient data to learn features automatically. In this chapter we’ll introduce feedforward networks as classifiers, and also apply them to the simple task of language modeling: assigning probabilities to word sequences and predicting upcoming words. In subsequent chapters we’ll introduce many other aspects of neural models, such as recurrent neural networks (Chapter 8), the Transformer (Chapter 9), and masked language modeling (Chapter 11). 2 CHAPTER 7 • NEURAL NETWORKS 7.1 Units The building block of a neural network is a single computational unit. A unit takes a set of real valued numbers as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of
as input, performs some computation on them, and produces an output. At its heart, a neural unit is taking a weighted sum of its inputs, with one addibias term tional term in the sum called a bias term. Given a set of inputs x1...xn, a unit has a set of corresponding weights w1...wn and a bias b, so the weighted sum z can be represented as: z = b+ X i wixi (7.1) Often it’s more convenient to express this weighted sum using vector notation; recall vector from linear algebra that a vector is, at heart, just a list or array of numbers. Thus we’ll talk about z in terms of a weight vector w, a scalar bias b, and an input vector x, and we’ll replace the sum with the convenient dot product: z = w · x+b (7.2) As defined in Eq. 7.2, z is just a real valued number. Finally, instead of using z, a linear function of x, as the output, neural units apply a non-linear function f to z. We will refer to the output of this function as activation the activation value for the unit, a. Since we are just modeling a single unit, the activation for the node is in fact the final output of the network, which we’ll generally call y. So the value y is defined as: y = a = f(z) We’ll discuss three popular non-linear functions f below (the sigmoid, the tanh, and the rectified linear unit or ReLU) but it’s pedagogically convenient to start with the sigmoid sigmoid function since we saw it in Chapter 5: y = σ(z) = 1 1+e −z (7.3) The sigmoid (shown in Fig. 7.1) has a number of advantages; it maps the output into the range (0,1), which is useful in squashing outliers toward 0 or 1. And it’s differentiable, which as we saw in Section ?? will be handy for learning. Figure 7.1 The sigmoid function takes a real value and maps it to the range (0,1). It is nearly linear around 0 but outlier values get squashed toward 0 or 1. Substituting Eq. 7.2 into Eq. 7.3 gives us the output of a neural unit: y = σ(w · x+b) = 1 1+exp(−(w · x+b)) (7.4) 7.1 • UNITS 3 Fig. 7.2 shows a final schematic of a basic neural unit. In this example the unit takes 3 input values x1, x2, and x3, and computes a weighted sum, multiplying each value by a weight (w1, w2, and w3, respectively), adds them to a bias term b, and then passes the resulting sum through a sigmoid function to result in a number between 0 and 1. x1 x2 x3 y w1 w2 w3 ∑ b σ +1 z a Figure 7.2 A neural unit, taking 3 inputs x1, x2, and x3 (and a bias b that we represent as a weight for an input clamped at +1) and producing an output y. We include some convenient intermediate variables: the output
layer for input w will be Exi = ei , the embedding for word i. We now concatenate the three embeddings for the three context words to produce the embedding layer e. 2. Multiply by W: We multiply by W (and add b) and pass through the ReLU (or other) activation function to get the hidden layer h. 3. Multiply by U: h is now multiplied by U 4. Apply softmax: After the softmax, each node i in the output layer estimates the probability P(wt = i|wt−1,wt−2,wt−3) In summary, the equations for a neural language model with a window size of 3, given one-hot input vectors for each input context word, are: e = [Ext−3;Ext−2;Ext−1] h = σ(We+b) z = Uh yˆ = softmax(z) (7.43) Note that we formed the embedding layer e by concatenating the 3 embeddings for the three context vectors; we’ll often use semicolons to mean concatenation of vectors. 24 CHAPTER 7 • NEURAL NETWORKS 7.7 Training the neural language model The high-level intuition of training neural language models, whether the simple feedforward language models we describe here or the more powerful transformer self-training language models of Chapter 9, is the idea of self-training or self-supervision that we saw in Chapter 6 for learning word representations. In self-training for language modeling, we take a corpus of text as training material and at each time step t ask the model to predict the next word. At first it will do poorly at this task, but since in each case we know the correct answer (it’s the next word in the corpus!) we can easily train it to be better at predicting the correct next word. We call such a model self-supervised because we don’t have to add any special gold labels to the data; the natural sequence of words is its own supervision! We simply train the model to minimize the error in predicting the true next word in the training sequence. In practice, training the model means setting the parameters θ = E,W,U,b. For freeze some tasks, it’s ok to freeze the embedding layer E with initial word2vec values. Freezing means we use word2vec or some other pretraining algorithm to compute the initial embedding matrix E, and then hold it constant while we only modify W, U, and b, i.e., we don’t update E during language model training. However, often we’d like to learn the embeddings simultaneously with training the network. This is useful when the task the network is designed for (like sentiment classification, translation, or parsing) places strong constraints on what makes a good representation for words. Let’s see how to train the entire model including E, i.e. to set all the parameters θ = E,W,U,b. We’ll do this via gradient descent (Fig. ??), using error backpropagation on the computation graph to compute the gradient. Training thus not only sets the weights W and U of the network, but also as we’re predicting upcoming words, we’re learning the embeddings E for each word that best
backpropagation cially for neural networks, it turns out to be the same as a more general procedure called backward differentiation, which depends on the notion of computation graphs. Let’s see how that works in the next subsection. 7.5.3 Computation Graphs A computation graph is a representation of the process of computing a mathematical expression, in which the computation is broken down into separate operations, each of which is modeled as a node in a graph. Consider computing the function L(a,b, c) = c(a+2b). If we make each of the component addition and multiplication operations explicit, and add names (d and e) for the intermediate outputs, the resulting series of computations is: d = 2 ∗ b e = a+d L = c ∗ e We can now represent this as a graph, with nodes for each operation, and directed edges showing the outputs from each operation as the inputs to the next, as in Fig. 7.12. The simplest use of computation graphs is to compute the value of the function with some given inputs. In the figure, we’ve assumed the inputs a = 3, b = 1, c = −2, and we’ve shown the result of the forward pass to compute the result L(3,1,−2) = −10. In the forward pass of a computation graph, we apply each operation left to right, passing the outputs of each computation as the input to the next node. e=a+d d = 2b L=ce a=3 b=1 c=-2 e=5 d=2 L=-10 forward pass a b c Figure 7.12 Computation graph for the function L(a,b, c) = c(a+2b), with values for input nodes a = 3, b = 1, c = −2, showing the forward pass computation of L. 7.5.4 Backward differentiation on computation graphs The importance of the computation graph comes from the backward pass, which is used to compute the derivatives that we’ll need for the weight update. In this example our goal is to compute the derivative of the output function L with respect 7.5 • TRAINING NEURAL NETS 17 to each of the input variables, i.e., ∂L ∂a , ∂L ∂b , and ∂L ∂ c . The derivative ∂L ∂a tells us how much a small change in a affects L. chain rule Backwards differentiation makes use of the chain rule in calculus, so let’s remind ourselves of that. Suppose we are computing the derivative of a composite function f(x) = u(v(x)). The derivative of f(x) is the derivative of u(x) with respect to v(x) times the derivative of v(x) with respect to x: d f dx = du dv · dv dx (7.29) The chain rule extends to more than two functions. If computing the derivative of a composite function f(x) = u(v(w(x))), the derivative of f(x) is: d f dx = du dv · dv dw · dw dx (7.30) The intuition of backward differentiation is to pass gradients back from the final node to all the nodes in the graph. Fig. 7.13 shows part of the backward computation at

Question:
what is nural network

","Neural networks are built out of neural units, originally inspired by biological neurons but now simply an abstract computational device. Each neural unit multiplies input values by a weight vector, adds a bias, and then applies a non-linear activation function like sigmoid, tanh, or rectified linear unit. In a fully-connected, feedforward network, each unit in layer i is connected to each unit in layer i+1, and there are no cycles. The power of neural networks comes from the ability of early layers to learn representations that can be utilized by later layers in the network. Neural networks are trained by optimization algorithms like gradient descent. Error backpropagation, backward differentiation on a computation graph, is used to compute the gradients of the loss function for a network. 26 CHAPTER 7 • NEURAL NETWORKS • Neural language models use a neural network as a probabilistic classifier, to compute the probability of the next word given the previous n words."
